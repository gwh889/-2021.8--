

## HTML(XHTML)

### Web标准的构成：结构、表现和行为三方面

```html
<!DOCTYPE html>//告诉浏览器按照html5规范来解析页面，还有XHTML规范
<html lang="en">//或zh-CN，指定html语言种类，告诉浏览器或搜索引擎根据语言种类做一些操作处理
<meta charset="UTF-8">//告诉浏览器用什么字符集进行存储解析,utf-8基本包含所有国家的语言
```

### HTML标签的语义化（标签的含义）

> 根据标签的语义，在合适得地方给一个最为合理的标签，让结构更清晰
>
> 作用：1.方便代码的阅读和维护
>
> 2.同时让浏览器或是网络爬虫可以很好地解析，从而更好的分析其中的内容
>
> 3.使用语义化标签会具有更好地搜索引擎优化
>
> div和span没有语义

### 标签

>1.排版标签
>
>1）标题标签：h1-h6
>
>2）段落标签：<p></p>
>
>3）水平线标签：<hr/>
>
>4）换行标签：<br/>
>
>5）div和span标签：没有语义
>
>2.文本格式化标签
>
>1）粗体<b></b>、<strong></strong>（强调的意思，语义更强烈，推荐使用）
>
>2）斜体<i></i>、<em></em>（强调的意思，语义更强烈，推荐使用）
>
>3）加删除线<s></s>、<del></del>（强调的意思，语义更强烈，推荐使用）
>
>4）加下划线<u></u>、<ins></ins>（强调的意思，语义更强烈，推荐使用）
>
>3.img标签属性：src（必写）、alt、title、width、height、border
>
>4.a链接标签：href（必写）、target（默认_self、_blank）
>
>5.相对路径（相对于html的路径）和绝对路径（具体的磁盘完整路径）

### 锚点

>1.使用相应的id名标注跳转目标的位置（找目标）
>
>2.使用<a href="#id名"></a>（被点击的）

### base标签

>1.设置整体链接打开状态<base target="_blank"/>
>
>2.base写到<head></head>之间
>
>3.把所有的连接都默认添加target="_blank"

```
预格式化文本（<pre></pre> 实际输入什么样，就什么样显示，不常用）
特殊字符：空格（&nbsp;)、小于号（&lt;)、大于号（&gt;)
```

### table

>1.属性：border,width,height,align,cellspacing（单元格之间距离）,cellpadding（单元格中文本与单元格边框距离）
>
>2.平时开发cellspacing,cellpadding,border设为0
>
>3.表格标题：在table下写<caption>表格标题</caption>
>
>4.合并单元格
>
>1）跨行合并：rowspan="合并单元格的个数"
>
>​      跨列合并：colspan="合并单元格的个数"
>
>2）顺序：先上后下，先左后右
>
>3）三部曲：要用跨行还是跨列、根据先上后下，先左后右找到目标单元格、删除多余单元格，删除目标单元格外的
>
>5.表格可以划分为thead、tbody、tfoot（表格的脚注之类）

### 列表

```html
概念：容器里承载着结构，样式一致的文字或图表的一种形式
特点：整齐、整洁、有序，跟表格类似，但是他的组合自由度会更高
无序列表、有序列表、
自定义列表：用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号
<dl><dt><dd></dd></dt></dl>
```

### 表单

>为了收集用户信息
>
>一个完整的表单由表单控件、提示信息和表单域三部分组成
>
>1.input控件:单标签
>
>type属性：text、password、radio、checkobox、button、submit、reset、image（图像形式的提交按钮，必写src）、file
>
>name属性、value属性、checked属性
>
>2.label标签
>
>作用：绑定一个表单元素，当点击label标签的时候，被绑定的表单元素就会获得输入的焦点
>
>两种用法：1）<label><input type="text"/></label>
>
>2）通过for和id来控制：<label for="nc"></label>  <input type="text" id="nc"/>
>
>3.textarea标签：文本域，多行文本，双标签
>
>4.select下拉列表（用的比较少，后期都是用div和ul实现的）

### 表单域

>form表单
>
>action:url地址
>
>method:get/post提交方式
>
>name:表示不同的表单域

html标签用小写，元素属性使用双引号，提倡checked="checked"，不提倡checked

## CSS2

>概念：层叠样式表，简称样式表
>
>作用：设置版面的布局和外观显示样式
>
>行内样式（没有实现样式和结构相分离）、内部样式（没有彻底分离）、外部样式表（<link rel="stylesheet" type="text/css" href="style.css"/>     rel="stylesheet"必写）：实现了完全分离和样式共享

### 选择器

>找到特定的HTML页面元素
>
>分类：基础选择器和复合选择器
>
>基础选择器
>
>1.标签选择器：用HTML标签作为选择器，按标签名分类，为页面某一类标签指定样式，不能差异化选择
>
>2.类选择器：为某一标签指定样式，可以写多个类名，可以使用多次，样式用的最多
>
>3.id选择器：是唯一的，只可以使用一次，与js搭配使用
>
>4.通配符选择器：*{}，匹配页面所有元素，会降低页面反应速度

### font字体

>1.font-size:px
>
>通常给body设置一个字体大小，防止不同浏览器默认大小不同
>
>2.font-family:可以写多种字体，按顺序寻找支持的字体显示，都不支持则默认，
>
>1）中文字体要加引号
>
>2）英文字体一般不加引号，如果字体中含有空格、#、$等符合，该字体必须要加引号，单引或双引
>
>3）英文字体要写在中文之前
>
>4）不支持中文字体时，可使用Unicode字体，要加引号
>
>3.font-weight:字体粗细
>
>normal（400）、bold（700）、100-900
>
>4.font-style：字体倾斜
>
>normal、italic(斜体)
>
>5.综合性写法
>
>font:font-style  font-weight  font-size/line-height  font-family，后两个不能少，是有顺序的

### css外观属性

>1.color:英文、rgb、十六进制
>
>2.text-align:left,center,right
>
>3.line-height:行间距,比字体大7-8像素左右
>
>4.text-indent:首行缩进
>
>em:字符倍数，text-indent：2em;首行缩进两个字符
>
>5.text-decoration:文本装饰
>
>none，取消下划线；underline，添加下划线

### 复合选择器

>是由两个或多个基础选择器，通过不同的方式组合而成
>
>目的是为了可以选择更准确更精细的目标元素标签
>
>#### 1.后代选择器（包含选择器）重要
>
>用来选择元素或元素组的子孙后代
>
>父级 子级{属性：属性值；属性：属性值}
>
>#### 2.子元素选择器
>
>只能选择儿子级元素  父级>子级
>
>#### 3.交集选择器（不常用）
>
>并且的意思，既...又...（p.red)，即是p标签又是red类标签
>
>#### 4.并集选择器（重要）
>
>两个或两个以上选择器样式相同（p,div{color:red;}),集体声明，用逗号隔开
>
>#### 5.链接伪类选择器（重要）
>
>用于向某些选择器添加特殊的效果。比如给链接添加特殊效果，比如可以选择第1个，第n个元素
>
>a:link 未访问的链接
>
>a:visited 访问过的链接
>
>a:hover 鼠标移动到链接上（最常用）
>
>a:active 按下鼠标，不松开
>
>以上4个按照以上lvha的顺序来写
>
>a标签有默认样式，因此需要单独设置
>
>一般用法：.nav a{color:;text-decoration:none;} a:hover{}

### 标签显示模式（重要）

>概念：标签是以什么方式进行显示，如div占一行，span一行可以放多个
>
>分类：块元素、行内元素、行内块元素
>
>### 1.块元素：
>
>```
><h1>-<h6>、<p>、<div>、<li>、<ul>、<ol>
>```
>
>特点：1）独占一行
>
>2）高度、宽度、外边距、内边距都可以控制
>
>3）宽度默认是容器（父级宽度）的100%
>
>4）是一个容器级盒子，里面可以放行内或块级元素
>
>注意：p标签不能放块级元素；h1~h6，dt都是文字类块级标签，里边不能放块级元素
>
>### 2.行内元素：
>
><a>、<span>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>
>
>特点：1）相邻行内元素在一行，一行可以显示多个
>
>2）宽、高直接设置是无效的
>
>3）默认宽度是它本身内容的宽度
>
>4）行内元素只能容纳文本或者其他行内元素
>
>注意：链接里不能再放链接，特殊情况a里面可以放块级元素，但给a转换一下块级模式最安全
>
>### 3.行内块元素：
>
><img/>、<input/>、<td>，可对他们设置宽度和对齐属性
>
>特点：1）和相邻行内元素（行内块）在一行上，但是之间会有空白缝隙，一行可以显示多个
>
>2）默认宽度就是它本身内容的宽度
>
>3）高度、行高、外边距以及内边距都可以控制
>
>三种模式相互转换：如，display:inline-block；

#### 行高

>行间距,比字体大7-8像素左右
>
>是基线和基线之间的距离（顶线、中线、基线、底线）
>
>使用行高实现单行文字垂直居中
>
>###### 行高=上距离+内容高度+下距离，上下距离平分行高-内容高度
>
>行高=高度：垂直居中
>
>行高>高度：文字偏下
>
>行高<高低：文字偏上

### css背景

>#### 1.背景颜色：
>
>background-color，默认transparent透明
>
>#### 2.背景图片：
>
>background-image:url(路径);url必写，地址不加引号，还可以设置为none
>
>#### 3.背景平铺：
>
>background-repeat，repeat平铺；no-repeat不平铺；repeat-x横向平铺；repeat-y纵向平铺
>
>#### 4.背景位置（position）重点
>
>background-position:right   top;
>
>1）必须指定background-image属性
>
>2）position后面是x坐标和y坐标，可以使用方位名词或者精确单位
>
>3）如果指定了一个方位名词，另一个默认居中，为50%
>
>4）如果只指定一个数值，那么该数用于x坐标，另一个默认是y坐标，默认居中
>
>5）如果指定两个值，两个值都是方位名词，则两个值前后顺序无关，比如left,top和top,left效果一致
>
>6）如果指定两个值，精确单位和方位名词混合使用，则第一个值是x坐标，第二个值是y坐标
>
>7）如果position后面是精确坐标，那么第一个一定是x，第二个一定是y
>
>background-position:10px   50px;
>
>background-position:center top;//超大背景图的做法，设置超出屏幕的高度就会有滚动条
>
>#### 5.背景附着
>
>背景是滚动的还是固定的
>
>background-attachment:scroll|fixed
>
>#### 6.背景简写（无固定顺序）
>
>background:背景颜色  背景图片地址  背景平铺  背景滚动  背景位置
>
>#### 7.背景透明（css3）
>
>background:rgba(0,0,0,0.3)
>
>1）最后一个参数是alpha透明度，取值范围值0-1之间
>
>2）我们习惯把0.3的0省略掉，这样写background:rgba(0,0,0,.3)
>
>3）注意：背景半透明是指盒子背景半透明，盒子里的内容不受影响
>
>4）因为是css3，所以低于ie9的版本是不支持的

### css三大特性

>#### 1.css层叠性
>
>概念：多种css样式的叠加
>
>原则：
>
>1）样式冲突，遵循的原则是就近原则。哪个样式离着结构近，就执行哪个样式
>
>2）样式不冲突，不会层叠
>
>#### 2.css的继承性
>
>子标签会继承父标签的某些样式，如文本颜色和字号
>
>想要设置一个继承的属性，只需要将他应用于父元素即可
>
>注意：1）恰当的使用继承可以简化代码，降低css样式的复杂性。
>
>2）子元素可以继承父元素的样式（text-，font-，line-这些元素开头的可以继承，以及color属性）
>
>#### 3.css的优先级（重点）
>
>###### 优先级
>
>如果选择器相同，则执行层叠性
>
>选择器不同，就会出现优先级问题
>
>| 标签选择器             | 计算权重 |
>| ---------------------- | -------- |
>| 继承或者*              | 0,0,0,0  |
>| 每个元素（标签选择器） | 0,0,0,1  |
>| 每个类，伪类           | 0,0,1,0  |
>| 每个ID                 | 0,1,0,0  |
>| 每个行内样式style=""   | 1,0,0,0  |
>| 每个！important重要的  | 无穷大   |

>1）specificity用一个四位的数，更像四个级别
>
>2）值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越
>
>3）关于css权重，我们需要一套计算公式来去计算，这个就是 CSS   specificity(特殊性)
>
>###### 权重叠加
>
>.nav  a  0,0,1,0+0,0,0,1=0,0,1,1
>
>注意：0,0,0,5+0,0,0,5=0,0,0,10无进位
>
>###### 继承的权重是0
>
>###### 我们修改样式时，一定要看该标签有没有被选中
>
>1）如果选中了，那么以上面的公式来计权重，谁大听谁的
>
>2）如果没被选中，那么权重是0，因为继承的权重是0
>
>p{ color:green}
>
>.class{ color:red}
>
>```
><div class="class"><p></p></div>
>```
>
>结果是绿色

### 盒子（重要）

盒子是网页布局的关键点，摆好盒子装内容

>组成：内容、边框、内边距、外边距
>
>#### 1.边框（border）
>
>border-width、border-style:dotted,solid,dashed、border-color
>
>border:border-width、border-style、border-color没有固定顺序
>
>border-top、bottom、right、left
>
>collapse是合并的意思，border-collapse:collapse表示相邻边框合并在一起 
>
>table,td,th{
>
>border:1px solid deeppink;
>
>border-collapse:collapse;//不写，表格的单元格边框是宽的，是2px
>
>}
>
>#### 2.内边距
>
>内容和边框有了距离，添加内边距盒子会变大
>
>padding:  ;1个值：上下左右；2个值：上下，左右；3个值：上，左右，下
>
>盒子的实际大小=内容宽度/高度+内边距+边框
>
>###### 解决设置内边距盒子变大的方法
>
>内边距一定要给，我们只能改变内容宽度width,让他减去多出来的内边距就可以了
>
>#### 3.padding不影响盒子大小情况
>
>如果没有给盒子指定宽度，此时，如果给盒子指定padding，则不会撑开盒子，因为块级元素默认宽度会等于父元素宽度
>
>#### 4.外边距
>
>盒子与盒子间距离，简写与padding相同
>
>#### 5.块级盒子水平居中
>
>1）有宽度
>
>2）a.左右外边距是auto    b.外边距是auto，margin:auto     c.margin:0  auto
>
>#### 6.text-align:center
>
>盒子内的文字水平居中，还可以让行内元素和行内块元素水平居中
>
>#### 7.插入图片和背景图
>
>1）插入图片我们用的最多，移动位置只能靠盒模型，padding和margin（产品类的）
>
>2）背景图片一般用于小图标背景火超大背景图片，只能通过background-position来移动位置
>
>#### 8.清除元素默认的内外边距
>
>```html
>*{margin:0;padding:0;}
>```
>
>注意：行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下边距，因为低版本ie不支持上下
>
>#### 9.外边距合并（塌陷）
>
>###### 1）相邻块元素垂直外边距的合并
>
>当上下相邻的两个块元素相遇时，如上边盒子有margin-bottom，下边盒子有margin-top，外边距取得是两者中的较大者，不是两者之和
>
>###### 2）左右盒子外边距不会合并
>
>###### 3）嵌套块级元素垂直外边距的合并（塌陷）
>
>父盒子嵌套子盒子，当给子盒子设置上外边距时，会同时将父盒子带下去，出现塌陷的问题
>
>解决方案：
>
>a.为父元素定义上边框
>
>b.为父元素定义上内边距
>
>c.可以为父元素添加overflow:hidden
>
>还有其他方法，如浮动、固定绝对定位的盒子不会
>
>#### 10.盒子模型布局稳定性
>
>按照优先级使用：width>padding>margin
>
>原因：1）margin会有外边距合并还有ie6下面margin加倍的bug，所以最后使用
>
>2）padding会影响盒子大小，还需要进行加减计算，其次使用
>
>3）width没有问题，我们经常使用宽度剩余法和高度剩余法来做
>
>去掉列表默认样式
>
>li{list-style:none}

### css的圆角

>border-radius:半径（数值或者百分比）      圆形
>
>border-radius:精确数值 （高度的一半）         圆角

### 盒子阴影

>box-shadow:水平阴影  垂直阴影  模糊距离（虚实，越大越虚） 阴影尺寸（影子大小）  阴影颜色  内/外阴影，默认是外(outset)不能写，内（inset）
>
>box-shadow:2px 2px 2px  2px  rgba(0,0,0,.3)
>
>前两个必须写，其他的可以省略

#### css书写规范

>1.选择器和大括号有空格
>
>2.属性冒号和值有空格
>
>3.多个选择器竖着写：
>
>.father,
>.son,
>p{	
>}
>
>4.选择器的嵌套层级应不大于3级，越靠后的限定条件尽可能精确
>
>5.属性定义必须另起行
>
>6.属性定以后必须有分号

### 浮动（重要）

>#### css布局的三种机制
>
>###### 普通流（标准流）
>
>块级元素：独占一行，从上向下顺序排列
>
>行内元素：从左到右顺序排列
>
>##### 浮动
>
>让盒子从普通流中浮动起来，主要作用让多个块级盒子一行显示
>
>###### 1.概念：
>
>设置了浮动的属性会脱离标准普通流的控制，移动到指定位置，浮动在标准文档流上
>
>###### 2.作用：
>
>1）让多个盒子水平排列成一行，使得浮动称为布局的重要手段
>
>2）可以实现盒子的左右对齐等等
>
>3）浮动最早是用来控制图片，实现文字环绕图片的效果
>
>浮：浮动的元素是浮在标准的文档流上，脱离标准流，脱标
>
>漏：浮动的元素不占有原来的位置，其他的元素会顶替到这个位置
>
>特：浮动的元素相当于display:inline-block的元素，排列在一行，但是中间没有空隙
>
>###### 注意：
>
>1）浮动的元素贴靠在一起，但如果父级元素装不下这些浮动的盒子，多出的盒子会另起一行
>
>2）通常我们会为浮动的元素添加标准流的父亲，最大的减小对标准流的影响
>
>##### 3.浮动元素与父盒子的关系
>
>不会与父盒子的边框重叠，也不会超过父盒子的内边距
>
>##### 4.浮动元素与兄弟盒子的关系
>
>浮动只会影响当前的或者是后面的盒子，不会影响前边的标准流

### 清除浮动

>什么时候清除：
>
>父级没高度、子盒子浮动了、影响了下面的布局
>
>#### 1.为什么要清除浮动
>
>很多情况，父盒子不好给高度，子盒子自动撑开父盒子，正常的标准流子盒子可以自动撑开父盒子，浮动的盒子不会自动撑开父元素
>
>#### 2.清除浮动的本质
>
>清除浮动主要是为了解决父级元素因为子级浮动引起内部高度为0的问题，清除浮动之后，父级就会根据子盒子自动检测高度。父级有了高度，就不会影响下面的标准流。
>
>#### 3.清除浮动的方法
>
>1）额外标签法（隔墙法）
>
>选择器：clear:both
>
>找到最后一个浮动的元素，在最后一个浮动元素后添加一个空标签，为他清除浮动
>
>2）父级添加overflow属性方法
>
>为父级添加overfolw为hidden|scroll|auto
>
>优点：代码简洁
>
>缺点：内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示溢出的元素
>
>3）使用after伪元素清除浮动
>
>###### :after方式是在浮动的最后添加的空元素，是标签法的升级版，好处是不用单独加标签了
>
>使用方法（在父元素上）：
>
>```css
>.clearfix:after{content:"";display:block;height:0;clear:both;
>    visibility:hidden;}
>.clearfix{*zoom:1;}//ie6、7专有
>```
>
>优点：符合闭合浮动思想，结构语义化正确
>
>缺点：由于ie6、7不支持:after，使用zoom:1触发hasLayout
>
>代表网站：淘宝、百度、网易
>
>4）使用双伪元素清除浮动
>
>```css
>.clearfix:before,
>.clearfix:after{
>    content:"";
>    display:table;
>}
>.clearfix:after{
>    clear:both;
>}
>.clearfix{
>    *zoom:1;
>}
>```
>
>优点：代码更简洁
>
>缺点：由于ie6、7不支持:after，使用zoom:1触发hasLayout
>
>代表网站：小米、腾讯等

### ps切片工具

>#### 1.用切片选中图片
>
>1）利用切片工具手动划出
>
>2）图层菜单---新建基于图层的切片
>
>3）利用标尺 基于参考线的切片（选择切片工具）
>
>4）先选择一整个的切片，切片工具--属性面板中有“划分”--可以等分数平分切图
>
>#### 2.导出切片
>
>文件菜单--存储为web设备所用格式--选择我们要的图片格式--点存储--别忘了选中的切片
>
>辅助线和切片使用及清除
>
>###### 辅助线和切片使用及清除
>
>视图菜单--清除辅助线/清除切片

切图插件Cutterman

### css属性书写顺序

>1.布局定位属性：display/position/float/clear/visiblity/overflow
>
>2.自身属性：width/height/margin/padding/border/background
>
>3.文本属性：color/font/text-decoration/text-align/vertical-align/white-space/break-word
>
>4.其他属性（css3）：content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient...

### 布局流程

>1.必须确定版心（可视区），我们测量可知
>
>2.分析页面的行模块，以及每个模块中的列模块。其实页面布局，就是一行行罗列而成
>
>3.制作HTML结构。我们还是遵循先有结构，后样式的原则。结构永远最重要
>
>4.然后开始运用盒子模型的原理，用过DIV+CSS布局来控制网页的各个模块

### 定位

>将盒子定在某一个位置，自由的漂浮在其他盒子（包括标准流和浮动）的上面
>
>组成：定位模式+边偏移（top,bottom,left,right）
>
>position:static,relative,absolute,fixed（模式）

#### 静态定位

>默认定位，无定位，按照标准流定位，无边偏移

#### 相对定位

>特点：
>
>1.相对自己原来在标准流中的位置来定位
>
>2.原来在标准流的区域继续占有

#### 绝对定位

>标准流的盒子定位总是以父级为准移动位置
>
>特点：
>
>1.绝对定位是以带有定位的父级元素来移动位置，如果父级元素没有定位，则以文档、浏览器窗口为准
>
>2.不保留原来的位置，完全是脱标的
>
>注：父级可以不是直接父级，可以是爷爷，一直往上找
>
>###### 口诀：子绝父相
>
>父级要占有位置，子级要任意摆放，这就是子绝父相的由来
>
>盒子重叠，覆盖就用子绝父相

产品类相关的用插入图片，不是背景

#### 固定定位

>固定定位是一种特殊的绝对定位，也不占有位置，完全脱标
>
>固定定位和父亲没有关系，不随着滚动条而滚动，以浏览器可视窗口为准

#### 定位的扩展

>绝对定位/固定定位设置margin:auto无法水平居中。
>
>##### 脱标设置水平居中
>
>left:50%;让盒子向右移动父元素的一半
>
>margin-left:-自身的一半;走多了，要向左走自身的一半
>
>##### 堆叠顺序
>
>后来者居上，同等级多个盒子绝对定位，后边盒子会压住前边盒子
>
>###### z-index的特性：
>
>1.z-index:负整数、0、正整数，默认是0，越大越靠上
>
>2.属性相同，按照书写顺序，后来者居上
>
>3.数字后边不加单位
>
>注：z-index只能用于相对定位、绝对定位和固定定位，标准流和浮动、静态定位无效
>
>###### 定位改变display属性
>
>1.可以用inlie-block转换为行内块
>
>2.可以用浮动float默认转换为行内块（类似，并不完全一样，folat是脱标的）
>
>3.绝对定位和固定定位也和浮动类似，默认转换的特性，转换为行内块
>
>##### 水平居中
>
>定位的盒子不写宽度默认的宽度是内容的宽度，要想使定了位的盒子内容居中，要写宽度，通常是100%，尤其是通栏的盒子，居中用text-align:center
>
>因为定位的转换为inline-block，默认以内容宽度为准，block宽度默认是通栏
>
>##### 注意：
>
>如果标准盒子设置定位absoulte、fixed、float就不会出现垂直外边距合并的问题

### 圆角矩形设置4个角

>border-top-right-radius
>
>border-top-left-radius
>
>border-bottom-right-radius
>
>border-bottom-left-radius

### css高级技巧

#### 元素的显示与隐藏

>##### 1.display（常用）
>
>display:none;//隐藏，不保留位置
>
>display:block;//显示元素
>
>##### 2.visibility（了解）
>
>visibility:hidden//隐藏，保留位置
>
>visibility:visible
>
>##### 3.overflow溢出（重点）
>
>默认是visible显示
>
>hidden、scroll（总是显示滚动条，不常用）、auto（内容超出显示滚动条，不超出不显示，不常用）

#### css用户界面样式

>##### 1.更改用户鼠标样式（滚动条兼容性太差，不研究）
>
>cursor:default(默认，小白)、pointer(小手)、move(移动)、text(文本)、not-allowed(禁止)
>
>##### 2.表单轮廓等
>
>outline:轮廓线，不常用，通常会去掉
>
>outline:0/none取消
>
>##### 3.防止表单域拖拽
>
>resize:none;//防止用户拖拽文本域

#### vertical-align垂直对齐

>只对行内元素和行内块元素起作用
>
>baseline（默认，基线对齐）、middle（垂直居中，中线对齐）、top（顶部对齐）、bootom（底部对齐）

#### 去除图片底侧空白缝隙

>1.vertical-align设置为非baseline，空隙是因为默认的基线对齐
>
>2.设置为块元素显示

#### 溢出的文字省略号显示

>##### 三部曲
>
>1.强制一行内显示
>
>white-space: nowrap;//强制一行内显示
>
>white-space: normal;//默认换行全部显示
>
>2.溢出隐藏
>
>overflow: hidden;
>
>3.文字溢出
>
>text-overflow: clip;//不显示省略号，直接裁剪
>
>text-overflow: ellipsis;//省略号显示

#### css精灵技术（CSS Sprites、CSS雪碧）

>网页中可能会用到很多小的背景图片，如果单个请求需要多次请求，多个图片合并在一起，只请求一次，减少服务器响应压力
>
>###### 作用：为了有效的减少服务器接收和发送请求的数据，提高页面的加载速度
>
>精确测量每个图片的大小和位置
>
>background: url(地址) no-repeat -157px  -107px;
>
>background-position中坐标一般都是负值，因为是让某个图片去原点
>
>##### 精灵图制作
>
>ps——ctrl+n建立背景——将所有的图放到该画板——存储为png格式

#### 滑动门技术

>背景图片按照文字内容的多少自由拉伸
>
>```css
>/*a是设置左侧背景，左门*/
>a{
>  /*因为是滑动门，左右推拉，跟文字内容多少有关系，此时需要用文字撑开盒子，就要用到行内块*/
>	display: inline-block;
>	height: 24px;
>	background: url(images/logo.png) no-repeat;
>	margin: 100px;
>	padding-left: 15px;
>	color: red;
>}
>/*span是设置有侧背景，右门*/
>a span{
>	display: inline-block;
>	height: 24px;
>	/*一定要注意span需要背景图右对齐*/
>	background: url(images/logo.png) no-repeat right top;
>	padding-right: 15px;
>}
>/*因为整个导航栏都是链接，所以a要包含span，这个导航都可以点击*/
><a href="#">
>	<span>首页</span>
></a>
>```

#### margin负值之美

>1.有border的li元素水平一行，重叠边框大小变成原来的2倍，margin-left:-1px;边框不加粗，显示正常（浮动）
>
>2.鼠标放上去显示边框
>
>div:hover{
>
>​    border:1px  solid #f40;
>
>​    position:relative;//定位的盒子会显示在最上边，会压住标准流和浮动的盒子，relative是为了占位置
>
>}

#### css三角之美

>1.宽高设置为0
>
>2.四个边框都要写，保留需要的边框颜色，其余不能省略，都改为transparent 
>
>3.为了照顾兼容性 低版本的浏览器，加上font-size:0;line-height:0;
>
>.sanjiao{
>				width: 0;
>				height: 0;
>				border-width: 10px;
>				border-style: solid;
>				border-color: transparent transparent transparent red;
>
>​                font-size:0;
>
>​                line-height:0;			
>
>}

### 品优购

>http://www.bitbug.net/将图片转换为ico图标
>
>引入ico:<link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
>
>为了兼容性，将ico标签放入根目录

#### 搜索引擎优化SEO

>##### 三大标签：
>
>title（不超过28个汉字）:网站名（产品名）-网站的介绍
>
>decsription（网站说明）:
>
><meta name="decsription" content="品优购是专业的综合网上购物商城"/>
>
>Keywords（关键字）：一般是6~8个关键字，电商类可以多一点
>
><meta name="Keywords" content="网上商城，购物，手机"/>

#### 字体图标(重要)

##### 优点

>可以做出和图片一样的效果，改变透明度、旋转度等
>
>但本质是文字，可以随意改变颜色、产生阴影、透明效果等
>
>本身体积更小，但携带的信息并没有消减
>
>几乎支持所有的浏览器
>
>移动设备的必备良药

##### 使用流程

>1.UI人员设置字体图标效果图（svg）
>
>2.前端人员上传生成兼容性字体文件包
>
>网站：icomoon字库（http://icomoon.io），阿里icon font字库（http://www.iconfont.cn）
>
>3.前端人员下载兼容字体文件包到本地
>
>4.把字体文件包引入到HTML页面中

>步骤：
>
>1.下载好的字体图标，解压，将其中的font文件夹放到自己的根目录，可以打开下载下来的html文件，直接点击每个字体图标右边的按钮复制到自己的html（粘贴的看不到）
>
>2.在html文件中引用
>
>```css
>@font-face{
>	font-family: 'icomoon';
>	src: url('fonts/icomoon.eot?7kkyc2');
>	src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'),
>         url('fonts/icomoon.woff?7kkyc2') format('woff'),
>         url('fonts/icomoon.ttf?7kkyc2') format('truetype'),
>         url('fonts/icomoon.svg?7kkyc2#iconfont') format('svg');
>     font-weight: normal;
>     font-style: normal;
>}
>div{
>	font-family: 'icomoon';
>	font-size: 5px;
>	color: red;
>}
><div>复制的图标</div>
>```
>
>

##### 追加图标

>原来的图标不够，需要添加新的
>
>将原来下载的json文件导入，选择新的图标，再下载

#### logo优化

>```html
><div class="logo">
>	<h1><a href="index.html" title="品优购">品优购</a></h1>
></div>
>```
>
>1.logo里首先放一个h1标签，目的是为了提权，告诉搜索引擎，这个地方很重要
>
>2.h1里放一个连接，可返回首页，给链接一个大小和logo背景图片
>
>3.链接里放文字（网站名称），为了搜索引擎收录我们，但文字不要显示出来
>
>做法：1）/*首行缩进，超出隐藏，淘宝用*/
>	              text-indent: -999em;
>
>​                  overflow: hidden;
>
>​             2）font-size: 0;//京东做法
>
>4.最后链接给一个title，鼠标放到logo上可看到网站提示文字

https://code.visualstudio.com/

#### 过渡

>transition:要过渡的属性  花费时间 运动曲线  何时开始(默认0s)
>
>transition:width  1s  ease 0s,height  1s  ease 0s;
>
>如果有多组属性，用逗号隔开
>
>transition:all  0.5s;all所有属性都会变化
>
>过渡写在本身上

## HTML5

>增加了视频、音频、三维等css特性，还有js

>增加的语义化标签：header、nav、article(内容标签)、section(块级标签)、aside(侧边栏标签)、footer(尾部标签)
>
>###### ie9需要转换为block，因为浏览器默认认为他是行内元素
>
>移动端更喜欢这些标签，pc端兼容较差

### 多媒体标签

>#### 1.音频：audio
>
>##### 三种格式：
>
>Ogg Vorbis(Firefox3.5,Opera10.5,Safari3.0)、MP3(IE9,Chrome3.0,Safari3.0)、Wav(Firefox3.5,Opera10.5,Chrome3.0)
>
>##### 属性：
>
>controls=“controls”;出现该属性，显示音频控件
>
>autoplay=“autoplay”;音频准备就绪，自动播放（谷歌浏览器将此属性禁用）
>
>loop=“loop”;循环播放
>
>src=“url”;地址
>
>##### 注意：
>
>不同浏览器支持不同格式，我们为音频准备多种格式
>
>```html
><audio controls="controls">
>   <source src="mp3" type="audio/mpeg">    
>   <source src="ogg" type="audio/ogg">    
></audio>
>```
>
>#### 2.视频：video
>
>```html
><video src="" controls="controls"></video>
><video autoplay="autoplay">
>   <source src="" type="video/mp4">
>   <source src="" type="video/ogg">
></video>
>```
>
>##### 属性：
>
>autoplay=“autoplay”；
>
>muted=“muted”;静音播放，在谷歌也可以自动播放
>
>controls=“controls”;出现该属性，显示视频控件（一般不使用，自动播放，静音）
>
>loop=“loop”;循环播放
>
>poster=“imgurl”;不自动播放时，显示的图片

### 新增input表单、属性

>input类型：email、url、date、time、month、week、number（数字）、tel（手机号码）、search（搜索框）、color（生成一个颜色选择表单）
>
>##### 属性
>
>required="required";不能为空
>
>###### placeholder="请输入"；提示文本，占位符
>
>autofocus="autofocus";自动获得焦点
>
>autocomplete="on/off";记录历史提示，默认是on，需要加name属性，成功提交过才会记录（平常off较多）
>
>###### multiple="multiple";多选，一般在type="file"，时选文件多选

## CSS3

>移动端优于pc端

### 属性选择器

>1.disabled:disabled;禁用
>
>button[disabled]{}选中有disabled属性的button
>
>###### 类选择器、属性选择器、伪类选择器，权重为10
>
>2.E[attr="e"]选中attr是e的E
>
>eg:input[type="search"]{}
>
>3.E[attr^="e"]选中attr属性是以e开头的E标签
>
>4.E[attr$="e"]选中attr属性是以e结尾的E标签
>
>5.E[attr*="e"]选中attr属性中任意位置有e的E标签

### 结构伪类选择器（第几个）

>###### 1.E:first-child
>
>eg:ul li:first-child选中ul中的第一个li
>
>###### 2.E:last-child
>
>###### 3.E:nth-child(n)（n不管是不是同一种类型）
>
>eg:ul li:nth-child(n)选中ul中的第n个li
>
>###### n可以是数字、关键字、公式
>
>关键字：even(偶数)、odd(奇数)
>
>公式：n是公式，但n从0开始；第0个元素超出了元素的个数会被忽略（2n是偶数、2n+1是奇数、5n选择0,5,10,15...、n+5选择从第5个开始往后选，包含5、-n+5选择前5个，包含第5个
>
>总结:  :nth-child(n)父元素的第n个孩子，不管是什么类型
>
>##### 4.E:first-of-type、E:last-of-type、E:nth-of-type(n)
>
>eg:div span:nth-of-type(2)选择div下类型是span的第二个

### 伪元素选择器

>::before、::after，必须要有content属性
>
>div::before{
>
>content:"内容";//在div里内容的前边放内容，与after相反
>
>width:100px;
>
>height:100px;//before和after创建一个元素，但是属于行内元素
>
>}
>
>伪元素：在dom里看不创建的元素
>
>伪元素和标签选择器的权重是1
>
>:focus获得焦点元素

### 伪元素和字体图标

>p::after{
>
>  content:'\ea50';
>
>  position:absolute;
>
>  top:10px;
>
>  right:10px;
>
>  font-family:'iconfont';
>
>}
>
>在p标签内容的后边添加定位字体图标，不用在dom添加标签

### CSS2D转换

>trasform属性，变形
>
>2D:二维坐标系旋转、平移
>
>###### 1.translate平移
>
>transform: translate(100px, 0);
>
>transform: translateX(100px);
>
> transform: translateY(0);
>
>###### 特点：
>
>1）不会影响其他元素，不像定位、margin
>
>2）对行内标签没效果
>
>3） translate(50%, 50%)百分比会相当于自身的比例
>
>水平垂直居中的另外一种方法：
>
>p{
>
> position:absolute;
>
> top:50%:
>
> left:50%;
>
> width:200px;
>
> height:200px;
>
> margin-top:-100px;//第一种方法
>
> margin-left:-100px;
>
> transform:translate(-50%,-50%);//第二种方法，走自己的一半
>
>}
>
>###### 2.rotate旋转
>
>transform:rotate(45deg);正数是顺时针旋转，负数是逆时针旋转，默认以元素中心旋转
>
>###### 为要旋转的元素添加过度：transition:all 0.3s;
>
>```css
>案例三角
>div {
>      position: relative;
>      width: 249px;
>      height: 35px;
>      border: 1px solid #000;
>}
>        
>div::after {
>      content: "";
>      position: absolute;
>      top: 8px;
>      right: 15px;
>      width: 10px;
>      height: 10px;
>      border-right: 1px solid #000;
>      border-bottom: 1px solid #000;
>      transform: rotate(45deg);
>      /* 旋转过渡 */
>      transition: all 0.2s;
>}
>/* 鼠标经过div里边得三角旋转 */
>div:hover::after {
>      transform: rotate(225deg);
>}
>```
>
>###### 修改旋转的中心点
>
>transform-origin: x y;
>
>x,y默认转换的中心点是元素的中心点（50% 50%）相当于center center
>
>还可以给x y设置像素或方位名词（top bottom left right center）
>
>```css
>案例：一个div旋转覆盖另外一个
>div {
>     width: 200px;
>     height: 200px;
>     border: 1px solid pink;
>     margin: 100px auto;
>     overflow: hidden;
>
>}
>        
>div::before {
>       content: "";
>       display: block;
>       width: 100%;
>       height: 100%;
>       background-color: hotpink;
>       transform: rotate(180deg);
>       transform-origin: left bottom;
>        /* 谁旋转写在谁上 */
>       transition: all 0.4s;
> }
>        
>div:hover::before {
>      transform: rotate(0deg);
>}
>```
>
>###### 3.缩放scale
>
>transform:scale(x,y);括号里数字是倍数，写一个值，宽高等比例缩放；小于1就是缩小
>
>优点：不会影响其他盒子，可以设置缩放的中心点，修改宽高的沿着坐标轴变化，会影响其他盒子
>
>###### 4. 3个属性综合写法
>
>transform:translate(100px, 0)  rotate(45deg)  scale(1.2);
>
>###### 位移和其他的同时存在，先写位移，再写其他

### CSS3动画

>##### animation
>
>```css
>/*1.定义动画 */
>@keyframes move {
>    /* 0%-100%动画序列 */
>    /* 开始状态 */
>    /* 第一种 */
>    0% {
>         transform: translate(0px);
>    }
>     /* 结束状态 */
>    100% {
>          transform: translate(1000px);
>     }
>    /* 第二种 */
>    from {
>         transform: translate(0,0);
>    }
>     /* 结束状态 */
>    to {
>          transform: translate(1000px,0);
>     }
>}
>div {
>     width: 200px;
>     height: 200px;
>     background-color: pink;
>     /* 2.调用动画 */
>     /* 动画名称 */
>     animation-name: move;
>     /* 持续时间 */
>      animation-duration: 2s;
>}
>```
>
>##### 动画序列
>
>动画是使元素从一种样式逐渐变成另一种样式的效果，可以改变任意多种样式任意多次
>
>```css
>@keyframes move {
>    /* 0%-100%动画序列 */
>    0% {
>         transform: translate(0,0);
>    }
>    25% {
>          transform: translate(1000px,0);
>     }
>    50% {
>          transform: translate(1000px,500px);
>     }
>    75% {
>          transform: translate(0,500px);
>     }
>    100% {
>          transform: translate(0,0);
>     }
>}
>```
>
>1.可以做多个状态的变化keyframe关键帧
>
>2.百分比要是整数
>
>3.里面的百分比是总的时间的划分
>
>###### 动画属性
>
>```css
> /* 动画名称 */
>animation-name: move;
>/* 持续时间 */
>animation-duration: 2s;
>/* 速度曲线,linear匀速，默认ease */
>animation-timing-function: ease;
>/* 何时开始,默认1s */
>animation-delay: 1s;
>/* 重复次数,infinite无限，也可写数字，多少次 */
>animation-iteration-count: infinite;
>/* 是否逆向播放,默认是normal,alternate是反方向 */
>animation-direction: alternate;
>/* 动画结束后的位置，默认backwards，回到起始位置；停留在结束位置，forwards */
>animation-fill-mode: forwards;
>/* 经过div让其停止动画,默认是running,不停止 */
>animation-play-state: paused;
>```
>
>简写：animation:name duration  timing-function delay iteration-count  direction  fill-mode
>
>前两个属性不能省，且delay一定要写在duration
>
>```css
>地图小圆点动态发散
> .map {
>     position: relative;
>     width: 747px;
>     height: 616px;
>     background-color: pink;
>     margin: auto;
>}        
>.city {
>    position: absolute;
>    top: 221px;
>    right: 196px;
>    color: #fff;
>}
>.dotted {
>     width: 8px;
>     height: 8px;
>     background-color: #09f;
>     border-radius: 50%;
>}
>.city div[class^="pulse"] {
>/* 保证小波纹在父盒子里水平居中，放大之后才会向四周发散 */
>      position: absolute;
>      top: 50%;
>      left: 50%;
>      transform: translate(-50%, -50%);
>      width: 8px;
>       height: 8px;
>       box-shadow: 0 0 12px #009dfd;
>       border-radius: 50%;
>       animation: pulse 1.2s linear infinite;
>}
>        
>.city div.pulse2 {
>       animation-delay: 0.4s;
>}
>.city div.pulse3 {
>       animation-delay: 0.8s;
>}
>@keyframes pulse {
>        0% {}
>        70% {
>        /* transform: scale(5);不用，因为他会让阴影变大 */
>            width: 40px;
>            height: 40px;
>            /* 透明度 */
>             opacity: 1;
>          }
>          100% {
>              width: 70px;
>              height: 70px;
>              opacity: 0;
>           }
>}
><div class="map">
>        <div class="city">
>            <div class="dotted"></div>
>            <div class="pulse1"></div>
>            <div class="pulse2"></div>
>            <div class="pulse3"></div>
>        </div>
></div>
>```
>
>###### 速度曲线
>
>linear(匀速)、ease(默认，以低速开始，然后加快，结束前变慢)、ease-in(以低速开始)、ease-out(以低速结束 )、ease-in-out(以低速开始和结束)、steps()指定了时间函数中的间隔数量（步长）
>
>animation-timing-function: step(10);分十步完成动画
>
>```css
> body {
>        background-color: #000;
>}
>div {
>        position: absolute;
>        width: 160px;
>        height: 80px;
>        background: url(img/bear.png) no-repeat;
>        /* 元素可以添加多种动画 */
>        animation: bear 1s steps(8) infinite, move 5s forwards;
>}
>        
>@keyframes bear {
>         0% {
>                background-position: 0 0;
>            }
>          100% {
>                background-position: -1280px 0;
>            }
>        }
>@keyframes move {
>            0% {
>                left: 0;
>            }
>            100% {
>                left: 50%;
>                /* margin-left: -100px; */
>                transform: translate(-50%);
>            }
>}
>```

### CSS 3D转换

>特点：近大远小、物体后边遮挡不见
>
>###### 多了一个z轴，垂直于屏幕，往外是正轴（接近眼睛），往里是负的

>##### 1.3D位移
>
>tansform:translateZ(100px);z轴一般都用px不怎么用百分比
>
>tansform:translate3d（x,y,z）；x,y,z不能省略，如果没有就写0
>
>###### 3D转换透视
>
>perpective透视
>
>透视也称为视距，视距就是人眼到屏幕的距离；
>
>眼睛离电脑越近，成像越大；距离越远，成像越小；
>
>3D透视理解成3D物体投影在2D平面内；
>
>单位是像素
>
>###### 注：透视写在被观察元素的父元素
>
>###### translateZ说的是物体和屏幕的距离，写在要观察的物体
>
>##### 2.3D旋转
>
>可以沿着x轴、y轴、z轴和自定义轴旋转
>
>x轴：transform: rotateX(108deg);左手法则，大拇指指向x轴正方向，手指弯曲的是正值
>
>```css
> body {
>      perspective: 500px;
> }
>        
>img {
>      display: block;
>      margin: 200px auto;
>      transition: all 1s;
> }
>img:hover {
>      transform: rotateX(108deg);
>}
>```
>
>y轴：transform: rotateY(108deg);左手法则，大拇指指向Y轴正方向，手指弯曲的是正值
>
>z轴：transform: rotateZ(108deg);和2D旋转效果一样
>
>自定义旋转：transform: rotate3d(1,0,0,45deg);（了解）

### CSS 3D呈现

>###### transform-style控制子元素是否开启三维立体环境
>
>transform-style:flat;默认，不开启3d
>
>transform-style:preserve-3d;开启3d
>
>此属性写在父盒子里，但影响的是子盒子
>
>```css
>实现两个盒子穿透的效果  
>body {
>       perspective: 500px;
>   }
>   
>   .box {
>       position: relative;
>       width: 200px;
>       height: 200px;
>       margin: 100px auto;
>       transition: all 2s;
>       transform-style: preserve-3d;
>   }
>   
>   .box:hover {
>       transform: rotateY(60deg);
>   }
>   
>   .box div {
>       position: absolute;
>       top: 0;
>       left: 0;
>       width: 100%;
>       height: 100%;
>       background-color: pink;
>   }
>   
>   .box div:last-child {
>       width: 100%;
>       height: 100%;
>       background-color: purple;
>       transform: rotateX(60deg);
>   }
><div class="box">
>   <div></div>
>   <div></div>
></div>
>```
>
>两面翻转的盒子（有bug）
>
>```css
>     body {
>            perspective: 400px;
>        }
>        
>        .box {
>            position: relative;
>            width: 300px;
>            height: 300px;
>            margin: 100px auto;
>            transition: all 2s;
>            transform-style: preserve-3d;
>        }
>        
>        .box:hover {
>            transform: rotateY(180deg);
>        }
>        
>        .front,
>        .back {
>            position: absolute;
>            top: 0;
>            left: 0;
>            width: 100%;
>            height: 100%;
>            border-radius: 50%;
>            font-size: 30px;
>            color: #fff;
>            text-align: center;
>            line-height: 300px;
>        }
>        
>        .front {
>            background-color: pink;
>            z-index: 1;
>        }
>        
>        .back {
>            background-color: purple;
>            /* 像手机一样背靠背旋转 */
>            transform: rotateY(180deg);
>        }
> <div class="box">
>        <div class="front">黑马</div>
>        <div class="back">程序</div>
></div>
>```
>
>3D导航栏
>
>```css
>       * {
>            margin: 0;
>            padding: 0;
>        }
>        
>        ul {
>            margin: 100px;
>        }
>        
>        ul li {
>            float: left;
>            width: 120px;
>            height: 35px;
>            list-style: none;
>            margin: 10px;
>            /* 因为box盒子也要旋转，所以给li加 */
>            perspective: 500px;
>        }
>        
>        .box {
>            position: relative;
>            width: 100%;
>            height: 100%;
>            transform-style: preserve-3d;
>            transition: all .4s;
>        }
>        
>        .box:hover {
>            transform: rotateX(90deg);
>        }
>        
>        .front,
>        .bottom {
>            position: absolute;
>            left: 0;
>            top: 0;
>            width: 100%;
>            height: 100%;
>        }
>        
>        .front {
>            background-color: pink;
>            z-index: 1;
>            transform: translateZ(17.5px);
>        }
>        
>        .bottom {
>            background-color: purple;
>            /* 负值，向前扑倒 */
>            transform: translateY(17.5px) rotateX(-90deg);
>        }
>    <ul>
>        <li>
>            <div class="box">
>                <div class="front">黑马</div>
>                <div class="bottom">程序</div>
>            </div>
>        </li>
>        <li>
>            <div class="box">
>                <div class="front">黑马</div>
>                <div class="bottom">程序</div>
>            </div>
>        </li>
>        <li>
>            <div class="box">
>                <div class="front">黑马</div>
>                <div class="bottom">程序</div>
>            </div>
>        </li>
>        <li>
>            <div class="box">
>                <div class="front">黑马</div>
>                <div class="bottom">程序</div>
>            </div>
>        </li>
>    </ul>
>```
>
>###### 旋转木马
>
>```css
>        body {
>            perspective: 800px;
>        }
>        
>        section {
>            position: relative;
>            width: 300px;
>            height: 200px;
>            margin: 200px auto;
>            transform-style: preserve-3d;
>            /* 添加动画 */
>            animation: rotate 10s linear infinite;
>            background: url(1/dog3.jpg) no-repeat;
>        }
>        
>        section:hover {
>            animation-play-state: paused;
>        }
>        
>        @keyframes rotate {
>            0% {
>                transform: rotateY(30deg);
>            }
>            100% {
>                transform: rotateY(360deg);
>            }
>        }
>        
>        section div {
>            position: absolute;
>            top: 0;
>            left: 0;
>            width: 100%;
>            height: 100%;
>            background: url(1/dog.jpg) no-repeat;
>        }
>        
>        section div:nth-child(1) {
>            transform: translateZ(300px);
>        }
>        
>        section div:nth-child(2) {
>            /* 转圈先旋转再移动没事 */
>            transform: rotateY(60deg) translateZ(300px);
>        }
>        
>        section div:nth-child(3) {
>            transform: rotateY(120deg) translateZ(300px);
>        }
>        
>        section div:nth-child(4) {
>            transform: rotateY(180deg) translateZ(300px);
>        }
>        
>        section div:nth-child(5) {
>            transform: rotateY(240deg) translateZ(300px);
>        }
>        
>        section div:nth-child(6) {
>            transform: rotateY(300deg) translateZ(300px);
>        }
>  <section>
>        <div></div>
>        <div></div>
>        <div></div>
>        <div></div>
>        <div></div>
>        <div></div>
>   </section>
>```

### 浏览器私有前缀

>为兼容老版本浏览器，如border-radius
>
>IE：-ms-
>
>火狐：-moz-
>
>谷歌、safari：-webkit-
>
>Opera：-o-

## 移动开发

手机浏览器的内核是Webkit。

### 视口

>视口（viewport）：浏览器页面内容的屏幕区域。视口可以分为布局视口、视觉视口和理想视口

>###### 布局视口（layout viewport）
>
>设置了布局视口，可解决pc网站在手机上显示的问题
>
>###### 视觉视口（visual viewport）
>
>是用户正在看的网站的区域
>
>###### 理想视口（ideal viewport）
>
>为了使网站在移动端有最理想的浏览和阅读宽度而定
>
>需要添加meta视口标签

><meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
>user-scalable:用户是否可以缩放，yes或no(1或0)
>initial-scale:初始缩放比,大于0的数字
>maximum-scale:最大缩放比
>minimum-scale:最大缩放比

### 二倍图

>物理像素：屏幕显示的小颗粒，是真是存在的，分辨率
>
>pc端：1px=1物理像素    手机端：1px=2物理像素（iphone8）
>
>以上就是物理像素比，开发时用的是px
>
>视网膜屏(Retina)技术：显示技术，可以把更多的物理像素点压缩至一块黑屏里，提高分辨率

>###### 插入图片
>
>多倍图：
>
>对于一张50px*50px的图片，在手机Retina屏中打开，按照刚才的物理像素会放到大倍数，这样会造成图片模糊
>
>在标准的viewport设置中，使用倍图来提高图片质量，通常使用2倍图
>
>设计的图片是100px*100px，然后用css样式将其设置为50px*50px

>###### 背景图片
>
>背景缩放background-size
>
>1.background-size:图片宽度 图片高度；//致谢一个参数，就是宽度，等比例缩放
>
>先有背景，再有background-size
>
>2.写百分比，对于父元素等比例缩放
>
>3.写cover，完全覆盖整个盒子，图片可能显示不全，高宽等比例拉伸
>
>4.写contain，使图片最大限度的适用于盒子，高宽等比例拉伸，当高度或宽度铺满盒子就不再进行拉伸，可能有部分空白区域
>
>###### 精灵图缩放
>
>先等比例缩放为原来的一半，在firework里，在测量坐标位置
>
> 最后用background-size缩放代码中的一半

### 移动端开发方案

>###### 1.单独制作移动端页面（主流）
>
>京东商城手机版、淘宝触屏版、苏宁易购手机版
>
>通过设备的不同，跳到不同的页面。域名前通常加m.来打开手机端
>
>###### 2.响应式页面兼容移动端（其次）
>
>三星手机官网
>
>通过屏幕宽度来改变样式，以适应不同的终端

### 移动端技术解决方案

>1.css初始化，推荐使用normalize.css，http://necolas.github.io/normalize.css/
>
>2.css3盒子模型：box-sizing:border-box;padding和border不会撑开盒子，有兼容性问题
>
>传统盒模型：之前学的，box-sizing:content-box;
>
>移动端用css3，pc端用传统盒模型
>
>3.标签a点击的高亮效果，会有背景色
>
>-webkit-tap-highlight-color:transparent;设置为透明
>
>-webkit-appearance:none;在ios上按钮和输入框去掉默认样式
>
>-webkit-touch-callout:none;禁用长按页面时会弹出菜单

### 移动端常见布局

>1.单独制作移动页面
>
>流式布局（百分比布局）
>
>flex弹性布局（强烈推荐）
>
>less+rem+媒体查询
>
>混合布局
>
>2.响应式页面兼容移动端
>
>媒体查询
>
>bootstrap

#### 流式布局（百分比布局）

>###### 京东手机端
>
>通过盒子的宽度设置成百分比根据屏幕的宽度进行伸缩，不受固定像素的限制，内容向两侧填充
>
>为防止内容会出现问题，会设置max-width,min-width

#### flex布局（弹性布局）

>###### 携程手机端
>
>操作方便，布局极为简单，移动端应用很广泛
>
>pc端浏览器支持情况差
>
>IE11或更低版本，不支持或仅部分支持

>##### 特点
>
>任何类型的盒子都可以指定为flex布局
>
>当我们为父盒子设为flex布局以后，子元素的float、clear和vertical-align属性将失效
>
>伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局
>
>##### 原理：
>
>通过给父盒子添加flex属性，来控制子盒子的位置和排列方式

>##### flex布局父项常见属性
>
>###### 1.flex-direction设置主轴 的方向
>
>默认的主轴是x轴，row，那么y轴就是侧轴，我们的元素是跟着主轴来排列的
>
>row：从左到右
>
>row-reverse：从右到左
>
>column：从上到下
>
>column-reverse：从下到上
>
>###### 2.justify-content设置主轴上的子元素排列方式
>
>flex-start:默认从头部开始
>
>flex-end:从尾部开始
>
>center:居中对齐
>
>space-around:平分剩余区域
>
>space-between:先两边贴边，再平分剩余空间（重要）
>
>###### 3.flex-wrap
>
>flex布局中，默认的子元素是不换行的
>
>nowrap:默认值，不换行
>
>wrap:换行
>
>###### 4.align-items设置侧轴上的子元素的排列顺序（单行使用）
>
>flex-start:默认从头部开始
>
>flex-end:从尾部开始
>
>center:居中对齐
>
>stretch:拉伸，但是子盒子不给高度（不常用）
>
>###### 5.align-content设置侧轴上的子元素的排列顺序（多行使用，换行）
>
>flex-start:默认从头部开始
>
>flex-end:从尾部开始
>
>center:居中对齐
>
>space-around:平分剩余区域
>
>space-between:先两边贴边，再平分剩余空间（重要）
>
>stretch:设置子元素高度平分父元素高度
>
>###### 6.flex-flow是flex-direction和flex-wrap的复合属性
>
>flex-flow:row wrap;
>
>##### flex布局子项常见属性
>
>###### 1.flex子项目占的份数（剩余空间所占的份数）
>
>flex:0;默认是0（圣杯布局）左右固定，中间自适应
>
>###### 2.align-self控制子项自己在侧轴的排列方式
>
>###### 3.order属性定义子项的排列顺序（前后顺序）
>
>数值越小，越靠前，默认0

#### 背景颜色线性渐变

>  background: -webkit-linear-gradient(left, #fa5a55, #fa994d);
>
>一定要添加私有前缀，方向名词可写top left这种的

#### rem适配布局

>文字随着屏幕大小而变换
>
>高度的设置
>
>元素宽和高等比例缩放

>###### rem单位
>
>1.是一个相对单位，类似于em，em是父元素字体的大小
>
>2.rem是相对于html元素的字体大小来说
>
>比如根元素（html）设置font-size=12px;非根元素设置width:2rem;则换成px就是24px
>
>3.rem的优点是可以通过修改html里面的文字大小来改变页面中元素的大小可以控制

##### 媒体查询

>###### 使用@media查询，可以针对不同的媒体类型定义不同的样式
>
>@media可以针对不同的屏幕尺寸设置不同的样式
>
>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面
>
>目前针对很多苹果手机、安卓手机，平板等设备都用得到多媒体查询

>##### 语法规范：
>
>@media  mediatype  and|not|only (media  feature){
>
>}
>
>######  mediatype:媒体类型；
>
>all:所有设备；print:用于打印机和打印预览；screen:用于电脑屏幕，平板电脑，智能手机
>
>###### 关键字
>
>and:可以将多个媒体特性连在一起，相当于“且”
>
>not:排除某个媒体类型，相当于“非”，可以省略
>
>only:指定某个特定的媒体类型，可以省略
>
>media  feature媒体特性，必须有小括号包含
>
>###### 媒体特性（用小括号包含）
>
>width:定义输出设备中页面可见区域的宽度
>
>min-width:定义输出设备中页面最小可见区域的宽度，包含等于
>
>max-width:定义输出设备中页面最大可见区域的宽度，包含等于
>
>例：
>
>1. @media screen and (max-width: 800px) {
>
>​      body{
>
>​        background-color: pink;
>
>​      }
>
> }
>
>2.@media screen and (min-width: 500px) and (max-width: 800px) {
>
>​      body{
>
>​        background-color: pink;
>
>​      }
>
> }
>
>###### 为防止混乱，media一般情况用从小到大的顺序
>
>###### screen 和and不能省略

>引入资源（理解）
>
>媒体查询引入不同的css文件，针对不同的屏幕尺寸
>
><link rel="stylesheet" href="" media="screen and (min-width:320px)">

##### less

>###### CSS弊端
>
>css是一门非程序语言，没有变量、函数、SCOPE(作用域)等概念
>
>css代码冗余度较大，不方便维护和扩展
>
>css没有很好的计算能力

>###### 关于Less
>
>Less是一门CSS扩展语言，也成为CSS预处理器
>
>常见的CSS预处理器：Saas、Less、Stylus
>
>Less是一门CSS预处理语言，它扩展了css的动态特性

>###### 安装less
>
>1.安装Less要先安装node
>
>2.安装好node后，输入node -v检测是否安装成功
>
>3.npm install -g less安装less
>
>4.lessc -v检测是否安装成功

>###### Less变量
>
>@变量名：值；
>
>命名规范：必须有@前缀、不能包含特殊字符、不能以数字开头、大小写敏感
>
>```less
>@color:pink;
>@font14:14px;
>div{
>    color: @color;
>    font-size: @font14;
>}
>```
>
>###### Less编译
>
>Less包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终通过解析器，编译生成对应的css文件
>
>使用vs-code的插件Easy LESS可将Less编译为CSS文件
>
>保存less文件时直接生成css文件
>
>###### Less嵌套
>
>```less
>//less嵌套，子元素的样式直接写到父元素里面就好了
>.header{
>    width: 200px;
>    height: 200px;
>    background-color: pink;
>    a{
>        color: red;
>    }
>}
>.nav{
>    .logo{
>        
>    }
>}
>```
>
>伪类、交集选择器、伪元素的写法，需要在前边加&
>
>```less
>a{
>  &:hover{
>
>  }
>}
>.nav{
>    &::before{
>        content:"";
>    }
>}
>```
>
>###### Less运算（重要）
>
>提供了+、-、*、/运算
>
>```less
>@border:5px + 5;
>div{
>    width: 200px - 50;
>    height: (200px + 50px) * 2;
>    border: @border solid red;
>    background-color: #666 - #222;
>}
>```
>
>1.运算符左右两侧必须敲空格
>
>2.两个数参与运算，如果只有一个数有单位，则最后的结果以这个单位为准
>
>3.如果两个的单位不同，以第一个单位为准

##### rem适配方案

>让一些不能等比自适应的元素，达到设备尺寸发生改变的时候，等比例适配当前设备
>
>rem适配方案技术使用
>
>方案1：less、媒体查询、rem
>
>方案2：flexible.js、rem(flexible.js淘宝出的，方案2更简单)

##### 方案1：

>市场主流给的设计稿以iphone6/7/8为准，宽度为750px
>
>###### 公式：
>
>页面元素的rem值=页面元素（px）/（屏幕宽度/划分的份数）
>
>屏幕宽度/划分的份数就是html  font-size的大小
>
>页面元素的rem值=页面元素（px）/ html  font-size的大小
>
>###### 步骤：
>
>1.首先我们先选一套标准尺寸 750为准
>
>2.我们屏幕尺寸除以我们划分的份数得到了html里面的文字大小，但是我们知道不同屏幕下得到的文字大小是不一样的
>
>3.页面元素的rem值=页面元素（px）/ html  font-size的大小
>
>```less
>// 将common.less引入到index.less
>
>@import "common";
>```
>
>

##### 方案2：

>用flexible.js默认将设备整个屏幕划分为10等份，不用写不同屏幕的媒体查询
>
>使用vscode中的cssrem插件自动转换为rem
>
>默认的html文字大小是16px

#### 响应式布局

>响应式需要一个父级作为布局容器，来配合子级元素来实现变化效果
>
>通过媒体查询来改变布局容器的大小
>
>```css
>        /* 超小屏幕 <768  布局容器宽度为100%*/
>        
>        @media screen and (max-width: 767px) {
>            .container {
>                width: 100%;
>            }
>        }
>        /* 小屏幕 >=768  布局容器宽度为750px*/
>        
>        @media screen and (min-width: 768px) {
>            .container {
>                width: 750px;
>            }
>        }
>        /* 中等屏幕 >=992  布局容器宽度为970px*/
>        
>        @media screen and (min-width: 992px) {
>            .container {
>                width: 970px;
>            }
>        }
>        /* 大屏幕 >=1200  布局容器宽度为1170px*/
>        
>        @media screen and (min-width: 1200px) {
>            .container {
>                width: 1170px;
>            }
>        }
>```
>
>###### 响应式导航栏
>
>```css
>       .container {
>            width: 750px;
>            margin: 0 auto;
>        }
>        
>        .container ul li {
>            float: left;
>            width: 93.75px;
>            height: 30px;
>            background-color: green;
>        }
>        
>        @media screen and (max-width: 767px) {
>            .container {
>                width: 100%;
>            }
>            .container ul li {
>                width: 33.33%;
>            }
>        }
>```
>
>

#### Bootstrap响应式布局

>###### 响应式开发
>
>Bootstrap的布局容器固定式.container
>
>###### 移动端开发
>
>.container-fluid类是流式布局百分百宽度，占据全部视口的容器，适合移动端开发

##### 栅格系统

>Bootstrap响应式布局采用栅格系统
>
>栅格系统：将页面内容的宽度划分为若干等宽的列，Bootstrap是划分为12列

>|                       | 超小屏幕     手机 (<768px) | 小屏幕    平板 (≥768px) | 中等屏幕    桌面显示器 (≥992px) | 大屏幕    大桌面显示器 (≥1200px) |
>| :-------------------: | -------------------------- | ----------------------- | ------------------------------- | -------------------------------- |
>| `.container` 最大宽度 | None （自动）              | 750px                   | 970px                           | 1170px                           |
>|        类前缀         | `.col-xs-`                 | `.col-sm-`              | `.col-md-`                      | `.col-lg-`                       |
>|    列（column）数     | 12                         |                         |                                 |                                  |

>row必须放到container布局容器里面
>
>实现列的平均划分，需要给列添加类前缀
>
>如果划分的列数，超出12份，则多出去的列会另起一行
>
>如果划分的列数，不够12份，则不会铺满container,有空白
>
>可以同时为1列指定多个设备的类名，作为自适应
>
>每一列默认有一个左右15px的padding
>
>```html
>       <div class="row">
>            <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">1</div>
>            <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">1</div>
>            <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">1</div>
>            <div class="col-lg-3 col-md-4 col-sm-6 col-xs-12">1</div>
>        </div>
>```

##### 列嵌套

>我们列嵌套时，最好加一个行row，这样可以取消父元素的padding值，而且高度会和父元素一样高
>
>```html
>   <div class="container">
>        <div class="row">
>            <div class="col-md-4">
>                <div class="row">
>                    <div class="col-md-6"></div>
>                    <div class="col-md-6"></div>
>                </div>
>            </div>
>            <div class="col-md-4"></div>
>            <div class="col-md-4"></div>
>        </div>
>    </div>
>```

##### 列偏移

>使用.col-md-offset-*类可以将列向右侧偏移
>
>```html
>   <div class="container">
>         <div class="row">
>            <div class="col-md-4">左侧</div>
>            <div class="col-md-4 col-md-offset-4">右侧</div>
>        </div>
>    </div>
>```
>
>偏移的份数是12-两个盒子的份数
>
>如果只有一个盒子，就偏移（12-盒子份数）/2居中对齐
>
>其实也是为右侧的盒子添加了margin值，但是是通过offset算出来的

##### 列排序

>通过使用.col-md-push-*和.col-md-pull-*可以改变列的顺序
>
>```html
>   <div class="container">
>        <div class="row">
>            <div class="col-md-4 col-md-push-8">左侧</div>
>            <div class="col-md-8 col-md-pull-4">右侧</div>
>        </div>
>    </div>
>```

##### 响应式工具

>利用媒体查询，使用这些工具可以针对不同设备展示或影藏页面内容
>
>|                 | 超小屏幕     手机 (<768px) | 小屏幕     平板 (≥768px) | 中等屏幕    桌面 (≥992px) | 大屏幕     桌面 (≥1200px) |
>| --------------- | -------------------------- | ------------------------ | ------------------------- | ------------------------- |
>| `.visible-xs-*` | 可见                       | 隐藏                     | 隐藏                      | 隐藏                      |
>| `.visible-sm-*` | 隐藏                       | 可见                     | 隐藏                      | 隐藏                      |
>| `.visible-md-*` | 隐藏                       | 隐藏                     | 可见                      | 隐藏                      |
>| `.visible-lg-*` | 隐藏                       | 隐藏                     | 隐藏                      | 可见                      |
>| `.hidden-xs`    | 隐藏                       | 可见                     | 可见                      | 可见                      |
>| `.hidden-sm`    | 可见                       | 隐藏                     | 可见                      | 可见                      |
>| `.hidden-md`    | 可见                       | 可见                     | 隐藏                      | 可见                      |
>| `.hidden-lg`    | 可见                       | 可见                     | 可见                      | 隐藏                      |

制作一个页面时，要看他是从大屏、小屏还是中屏开始变换布局，从开始变化时候的等级作为划分等分的设备

## JS基础

>渲染引擎：用来解析html和css，俗称内核
>
>JS引擎：也称JS解释器。用来读取网页中的JavaScript代码，对其处理后运行，比如chrome浏览器的v8,逐行解释执行，所以叫脚本

>###### 由三部分组成：ECMAScript、DOM、BOM
>
>ECMAScript:JavaScript(网景公司)、Jscript(微软公司)
>
>规定了JS的编程语法和基础核心知识，是所有浏览器厂商共同遵守的一套JS语法工业标准
>
>DOM：文档对象模型，对页面的各种元素进行操作
>
>BOM：浏览器对象模型，通过BOM可以操作浏览器窗口

#### JS的引用

>行内式：<input type="text" onclick="alert('ss')">
>
>内嵌式：<script></script>
>
>外联式：<script src="index.js"></script>
>
>JS推荐使用单引号，html用的双引号

>注释：
>
>单行：ctrl+/    //
>
>多行：shift+alt+a   /**/

输入输出语句

>prompt('请输入你的年龄')；输入框  var age=prompt('请输入你的年龄')；
>
>alert();
>
>console.log();

#### 变量

>###### 变量用于存放数据的容器，通过变量名获取数据，甚至可以修改
>
>本质：是程序在内存中申请的一块用来存放数据的空间
>
>使用：声明；赋值； var age=10;     var会开辟空间
>
>声明并赋值叫初始化

>###### 更新变量，以最后一次赋值为准
>
>###### 同时声明多个变量，var age=18,address="村"；
>
>###### 声明不赋值，是undefined
>
>###### 不声明不赋值，报错
>
>###### 不声明，直接赋值，也可使用，但是不推荐使用，是全局变量

##### 命名规则

>由字母、数字、下划线、美元符号组成
>
>不能以数字开头、区分大小写、不能是关键字和保留字、遵循驼峰命名法、变量有意义
>
>用name做变量名，有的浏览器有特殊含义，尽量不用他做变量名

#### 数据类型

>不同的数据占用的存储空间是不同的，为了便于把数据分成所需内存大小不同的数据，充分利用存储空间
>
>JavaScript是弱类型或者动态语言，js的变量数据类型是在程序运行的过程中，根据右边的值来确定
>
>var x=10;
>
>x='pink';体现了js是动态语言

>###### 分类：
>
>简单数据类型：Number（包含整型和浮点型）、Boolean、String、Undefined、null(空值)
>
>###### 1.Number
>
>以0开头的是八进制、0x开头是16进制、
>
>数字型范围：Number.MIN_VALUE~Number.MAX_VALUE
>
>无穷大：Infinity;-Infinity是无穷小
>
>NaN非数字
>
>isNaN()方法用来判断非数字，是数字返回false,非数字返回true;eg:isNaN(12)
>
>###### 2.字符串类型（String）
>
>单双引号都可以，推荐单引号；引号嵌套时  外单内双，或外双内单
>
>转义字符：\n换行、\\\斜杠、\t tab缩进、\b空格
>
>length属性：字符串长度
>
>字符串拼接：字符串+任何类型=字符串
>
>###### 数值相加，字符相连
>
>变量和字符串拼接：引引加加
>
>###### 3.Boolean类型
>
>true和false，1和0
>
>声明变量未定义：undefined+数值=NaN
>
>null+数值=原数值

>typeof  变量；获取数据类型，变量是null，返回object
>
>谷歌：字符串是黑色，数值是蓝色
>
>字面量：一眼看上去是什么类型

>##### 数据类型转换
>
>###### 1.转换为字符串
>
>1）变量.toString();
>
>2）String(变量);强制换行
>
>3）字符串拼接；隐式转换
>
>###### 2.转换为数字类型（重点）
>
>1）parseInt(字符串变量)；得到的是整数，向下取整，无进位
>
>eg:parseInt('120px');转换为数据类型是120，会去掉px
>
>​      parseInt('rem120px');NaN
>
>2）parseFloat(字符串变量)；可以得到小数
>
>3）Number(字符串变量)；强制类型转换
>
>4）利用运算符号-，*，/隐式转换
>
>eg：var x='123'-'120';结果是3
>
>###### 3.转换为布尔类型
>
>Boolean();' '、0、NaN、null、undefined返回的都是false,其余都是true

>解释性语言：运行时进行解释，并立即执行（JS）
>
>编译性语言：在代码执行前编译，生成中间代码（java）
>
>标识符：指开发人员自己起的名字
>
>关键字：指Js本身已经用了的字，不能再用他们做变量名、方法名
>
>保留字：预留的"关键字"，未来可能是关键字

#### 运算符

>也叫操作符
>
>###### 算数运算符：+、-、*、/、%
>
>注：浮点数有精度问题，运算会有问题，所以尽量避免浮点数运算
>
>不要直接判断两个浮点数是否相等，也会有问题

>表达式：由数字、运算符、变量等组成的式子
>
>是表达式都会有一个返回值，右边是表达式，再把结果给左边

>###### 递增和递减运算符
>
>与变量搭配使用
>
>前置（先加后返回）和后置（先返回原值后自加）

>###### 比较运算符
>
>关系运算符，返回一个布尔值
>
>==默认转换数据类型，把字符串转换为数据类型
>
>eg：18=='18'    true
>
>===完全一模一样，值和数据类型都一样
>
>eg：18=='18'    false

>###### 逻辑运算符
>
>&&、||、！用于多个条件的判断
>
>&&：有一个为假结果就是假
>
>||：有一个为真结果就是真
>
>！：取反
>
>###### 逻辑与短路运算：表达式1是真，返回表达式2；表达式1是假，返回表达式1
>
>###### 逻辑或短路运算：表达式1是真，返回表达式1；表达式1是假，返回表达式2

>###### 赋值运算符
>
>=、+=、-=、*=、/=、%=

>###### 运算符优先级
>
>小括号>一元运算符（++、--、！）>算数运算符>关系运算符>相等运算符>逻辑运算符（先与后或）、赋值运算符、逗号运算符

#### 流程控制

>控制代码按照什么结构顺序来执行
>
>###### 主要的三种结构：顺序结构、分支结构、循环结构
>
>###### 顺序结构：依次执行
>
>###### 分支流程控制
>
>1）if分支语句
>
>双分支、多分支
>
>2）三元表达式
>
>由三元运算符组成的式子称为三元表达式，简化版的if双分支
>
>条件表达式？表达式1：表达式2；真返回表达式1，假返回表达式2
>
>3）switch语句
>
>也是多分支语句，值相对固定的适合用
>
>```js
>switch(表达式){//表达式经常写成变量
>
>​    case  value1:
>
>​          执行语句1；
>
>​           break;
>
>​     case  value2:
>
>​          执行语句1；
>
>​           break;
>
>​       ...
>
>​      default:
>
>​            执行最后的语句；
>
>}
>```
>
>default都没有执行要执行的
>
>表达式和value值必须是全等于才执行
>
>如果不写break，会继续向下执行

>###### switch和if else if的区别
>
>固定值用switch，判断范围用if
>
>switch效率高，if效率低
>
>分至少用if,分支多用switch

>##### 循环控制
>
>循环目的：可以重复执行某些代码
>
>for循环：有计数器的存在、双重for循环、循环条件和数字相关
>
>eg:9*9乘法表、三角形
>
>while循环：条件表达式为true，循环体一直执行、应该有计数器、应该也有操作表达式，防止死循环
>
>do while循环：先执行一次循环体，再判断条件，至少会执行一次

>##### 关键字continue和break
>
>continue:用于立即跳出本次循环，继续执行其他。用于排除某一些条件
>
>break:退出整个循环

#### 数组

>可以把一组相关的数据一起存放，并提供方便的访问方式
>
>###### 数组是指一组数据的集合，其中的每个数据被称为元素，在数组中可以存放任意类型的元素。数组是一种将一组数据存储在单个变量名下的
>
>###### 1.创建数组
>
>1.var arr=new Array();//创建空数组
>
>2.var arr=[];//利用数组字面量创建数组，多个数据，用逗号隔开
>
>###### 2.获取数组中元素
>
>数组名[索引号]//没有的数组元素是undefined
>
>##### 3.遍历数组
>
>for循环（数组.length）
>
>##### 4.数组中新增元素
>
>1)修改length长度
>
>arr.length=5;//数组长度为5，空值是undefined
>
>2)修改索引号
>
>arr[3]='pink';//原本无索引为3号的元素，追加元素，已占用的会替换原来的元素

>##### 冒泡排序（依次比较 两个元素，从小到大或者从大到小）
>
>```js
>        var arr = [5, 4, 3, 2, 1];
>        for (var i = 0; i <= arr.length - 1; i++) {//趟数
>            for (var j = 0; j <= arr.length - i - 1; j++) {//每一趟交换次数
>                if (arr[j] > arr[j + 1]) {
>                    var temp = arr[j];
>                    arr[j] = arr[j + 1];
>                    arr[j + 1] = temp;
>                }
>            }
>        }
>```
>
>

#### 函数

>就是封装了一段可以被重复执行调用的代码块，就是让大量代码重复使用
>
>##### 函数使用：
>
>1.声明    2.调用
>
>##### 函数的参数
>
>声明时是形参，形参是接收实参的，可以看做是不用声明的变量
>
>调用时是实参
>
>##### 函数形参和实参个数匹配问题
>
>1.个数相等，正常输出
>
>2.实参个数多余形参个数，取到形参个数
>
>3.形参个数多于实参个数，结果是NaN，因为多的形参是默认值是undefined
>
>##### 函数返回值
>
>在 函数里写    return 需要返回的结果;
>
>通常用变量接收函数的返回值
>
>1.return可终止函数，遇到return，函数结束，return后的代码不被执行
>
>2.return只能返回一个值
>
>3.返回多个值，可以返回一个数组
>
>4.函数如果没有return，则返回undefined

>##### break,continue,return的区别
>
>break：结束当前循环体（for或while）
>
>continue：跳出本次循环，继续执行下次循环（for或while）
>
>return：不仅可以退出循环，还能返回return语句中的值，同时还可以结束当前函数的函数体内代码

>##### arguments的使用
>
>当我们不确定有多少个参数传递的时候，可以用arguments来获取。在JS中，arugments实际上是当前函数的一个内置对象。所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有实参
>
>arguments是通过伪数组来展示的,只有函数才有arguments
>
>###### 伪数组：并不是真正意义上的数组
>
>1.但具有数组的length属性，argument.length
>
>2.按照索引的方式进行存储,argument[0]
>
>3.他没有真正数组的一些方法，pop()  push()等等
>
>可按照数组遍历的方式，遍历arguments

>##### 函数声明的两种方式
>
>1.利用函数关键字function定义函数
>
>2.函数表达式（匿名函数）
>
>var  fn=function() {};
>
>调用也是   变量名();
>
>1）函数表达式声明方式和声明变量差不多，只不过变量里存的是值，函数表达式里存的是函数
>
>2）函数表达式也可以进行参数传递
>
>3）fn是变量名，不是函数名

#### JavaScript作用域

>作用域：就是代码名字（变量）在某个范围内起作用和效果，目的是为了提高程序的可靠性，更重要的是减少命名冲突
>
>##### JS作用域两大类（es6之前）：全局作用域  局部作用域
>
>全局作用域：整个script标签，或者是一个单独的js文件
>
>局部作用域（函数作用域）：在函数内部就是局部作用域，这个代码的名字只在函数内部其效果和作用
>
>###### 不同作用域下变量名冲突不影响
>
>##### 变量作用域
>
>根据作用域的不同把变量分为全局变量和局部变量
>
>1.全局变量：在全局作用域下的变量，在全局下都可以使用
>
>2.局部变量：在局部作用域下的变量，只能在函数内部使用的变量
>
>注：如果在函数内部，没有声明直接赋值的变量也是全局变量；形参是局部变量
>
>3.从执行效率来看全局变量和局部变量
>
>1）局部变量：只在函数内部使用，当其所在代码块被执行时，会被初始化；当代码块运行结束后，会被销毁，节省内存空间
>
>2）全局变量：在任何地方都可以用，只有浏览器关闭时才会被销毁，比较占内存
>
>###### 目前js还没有块级作用域，在es6时新增的块级作用域
>
>```js
>eg：
>if(5>3){
>  var num=5;
>}
>console.log(num);//不报错，java就会报错
>```

#### 作用域链

>内部函数访问外部函数的变量，采取的是链式查找的方式来决定取哪个值，这种结构称为作用域链。就近原则

#### 预解析

>```js
>1.console.log(num);//报错未定义
>2.
>  console.log(num);//undefined，坑1
>  var num=10;
>//以上代码相当于执行了以下代码
>  var num；
>  console.log(num);
>  num=10;
>3.
>  fn();
>  function fn(){}
>4.
>  fun();//报错，坑2
>  var fun=function(){}//函数表达式声明函数，调用函数必须写在后边
>```
>
>1.js引擎运行js分为两步：预解析  代码执行
>
>1）预解析js引擎会把js里面的所有var还有function提升到当前作用域的最前面
>
>2）代码执行，按照代码书写的顺序从上往下执行
>
>2.预解析分为变量预解析（变量提升）和函数预解析（函数提升）
>
>1）变量提升就是把所有的变量声明提升到当前的作用域最前边，不提升赋值操作
>
>2）函数提升就是把所有的函数声明提升到当前作用域的最前边，不提升调用函数
>
>```js
>f1();
>console.log(c);
>console.log(b);
>console.log(a);
>function f1(){
>    var a=b=c=9;
>    //相当于var a=9;b=9;c=9;b和c是全局变量
>    //集体声明是var a=9,b=9,c=9;
>    console.log(a);
>    console.log(b);
>    console.log(c);
>}
>//预解析提升后
>function f1(){
>    var a=b=c=9;
>    var a;
>    a=b=c=9;
>    console.log(a);
>    console.log(b);
>    console.log(c);
>}
>f1();
>console.log(c);
>console.log(b);
>console.log(a);
>```
>
>

#### JavaScript对象

>对象是具体的一个事物
>
>###### 在JS中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数组、数值、函数等。
>
>对象由属性和方法组成。
>
>属性：事物的特征，在对象中用属性来表示（常用名词）
>
>方法：事物的行为，在对象中用方法来表示（常用动词）
>
>JS中的对象表达更清晰、更强大

##### 创建对象的三种方法

>##### 第一种
>
>1.利用字面量创建对象
>
>```js
>var obj={
>    uname:'张三'，
>    age:18,
>    sex:'男'，
>    sayHi:function(){
>        console.log('hi~');
>    }
>}
>1）里面的属性和方法采用键值对的形式
>2）多个属性或方法中间用逗号隔开
>3）方法冒号后面跟的是一个匿名函数
>```
>
>2.使用对象
>
>1）调用对象的属性：对象.属性值；eg：obj.uname
>
>2）调用属性的另一种方式：对象名['属性名']；eg：obj['uname']
>
>3)调用对象的方法
>
>obj.sayHi();

>##### 第二种
>
>利用new Object创建对象
>
>```js
>var obj=new Object();//创建一个空对象
>obj.uname='张三'；
>obj.sayHi=function(){
>
>}
>1)我们利用的是等号=赋值的方法添加对象的属性和方法
>2）每个属性和方法用分号隔开
>```
>
>

##### 变量和属性,函数和方法的区别

> 变量和属性
>
> 相同点：用来存储数据
>
> 不同点：单独声明并赋值，使用的时候单独写变量名，单独存在；属性在对象里面不需要声明，使用的时候必须是  对象.属性
>
> 函数和方法
>
> 相同点：都是实现某种功能，做某件事的
>
> 不同点：函数单独声明，并且调用的  函数名() 单独存在；方法在对象里面，调用的时候  对象.方法()

##### 构造函数

>##### 第三种
>
>利用构造函数创建对象
>
>前两种方法一次只能创建一个对象，里面的很多属性和方法是大量相同的，因此可以利用函数的方法，重复这些相同的代码，我们把这个函数称为构造函数
>
>构造函数：就是把对象里面一些相同的属性和方法抽象出来封装到函数里面
>
>构造函数的语法格式
>
>```js
>function 构造函数名(){
>    this.属性=值；
>    this.方法=function(){}
>}
>new 构造函数名();//调用
>例如：
>function Star(uname,age,sex){
>    this.name=uname;
>    this.age=age;
>    this.sex=sex;
>}
>var ldh=new Star('刘德华',18,'男');//调用函数返回的就是一个对象
>ldh.name;//ldh['name']
>```
>
>1.构造函数首字母要大写
>
>2.构造函数不需要return就可返回结果
>
>3.调用构造函数必须使用new
>
>4.构造函数封装在函数里面，是泛指的某一大类；对象是特指
>
>5.我们利用构造函数创建对象的过程也称为对象的实例化

>##### new关键字执行过程
>
>1.new构造函数可以在内存中创建一个空的对象
>
>2.this就会指向刚才创建的空对象
>
>3.执行构造函数里面的代码，给这个空对象添加属性和方法
>
>4.返回这个对象（不需要return）

##### 遍历对象

>for...in语句用于对数组和对象进行遍历操作
>
>```js
>var obj={
>    name:'pink',
>    age:18,
>    sex:'男'
>}
>for(var k in obj){
>    console.log(k);//k变量输出得到的是属性名
>    console.log(obj[k]);//obj[k]得到的是属性值
>}
>```
>
>

##### 内置对象

>JS中的对象分为：自定义对象、内置对象、浏览器对象
>
>前两种对象是JS基础内容，属于ECMAScript;第三种是JS独有的
>
>##### 什么是内置对象？
>
>就是指JS语言自带的一些对象，供开发者使用，并提供了一些常用或基本而必要的功能
>
>如：Math、Date、Array、String等
>
>可用MDN查询

##### Math对象

>不是一个构造函数，不用使用new调用，直接使用里面的属性和方法即可
>
>1.Math.PI;//圆周率
>
>2.Math.abs();//绝对值，Math.abs(’-1‘);隐式转换，会打字符串转换为数值
>
>3.Math.max();//min
>
>###### 三个取整的方法
>
>4.Math.floor();//向下取整，往最小了取
>
>5.Matn.ceil();//向上取整，往最大了取
>
>6.Math.round();//四舍五入，Math.round(-1.5)结果为-1,其他正常，负数遇.5的特殊情况
>
>7.random()随机数方法
>
>1）返回随机小数，0<=x<1
>
>2）这个方法里不跟参数
>
>3）两个数之间的随机整数，包含这两个数
>
>```js
>Math.floor(Math.random() * (max - min)) + min；
>```
>
>4）随机点名
>
>```js
>function getRandom(min,max){
>return Math.floor(Math.random() * (max - min)) + min；
>}
>    var arr=['张三','李四','王五']；
>console.log(arr[getRandom(0,arr.length-1)])；
>```
>
>随机猜数游戏
>
>```js
>var random=genRandom(1,10);
>while(true){
>var num=prompt('你来猜？请输入1-10之间的一个数字')；
>if(num>random){
>       alert('你猜大了')；
>    }else if(num<random){
>        alert('你猜小了')
>    }else{
>        alert('猜对了')；
>       break;
>     }
>     }
>    //限制只有10次机会，将while循环改为for循环
>```

##### Date日期对象

>是一个构造函数，必须使用new关键字来创建对象
>
>1.new  Date();//不写参数，返回当前系统的当前时间
>
>2.new Date(2020-9-1);//写的时间
>
>var date=new Date();
>
>date.getFullYear();
>
>date.getMonth()+1;//加1才是当前月份
>
>date.getDate();//返回几号
>
>date.getDay();//返回的0是周日，1-6是周一到周六
>
>date.getHours();//返回小时
>
>date.getMinutes();//返回分
>
>date.getSeconds();//返回秒
>
>获得总毫秒数（时间戳），是距离1970年1月1日过了多少毫秒
>
>1.通过valueOf()   getTime()
>
>date.valueOf();      date.getTime();
>
>2.简单写法
>
>var date1=+new Date();
>
>3.H5新增的
>
>Date.now();
>
>###### 倒计时案例
>
>```js
>function countdown(time){
>var nowTime=+new Date();//返回当前时间的总毫秒数
>var inputTime=+new Date(time);
>    var times=(inputTime-nowTime)/1000;//剩余时间的总秒数
>    var d=parseInt(times/60/60/24);//天数
>    var h=parseInt(times/60/60%24);//小时
>    var m=parseInt(times/60%60);//分
>    var s=parseInt(times%60);//秒
>    return d+'天'+h+'时'+m+'分'+s+'秒'；
>    }
>    ```

##### 数组对象

>创建数组的第二种方式
>
>var arr=new Array(2);//创建一个长度为2的空数组
>
>var arr=new Array(2,3);//存了2和3两个元素的数组
>
>###### 检测是否为数组
>
>1）instanceof运算符 ，他可以用来检测是否为数组
>
>var arr=new Array();
>
>arr instanceof Array//返回true
>
>2）Array.isArray(参数),H5新增
>
>Array.isArray(arr);//返回true
>
>##### 添加删除数组元素的方法
>
>1.push();在数组末尾添加一个或多个数组元素
>
>1）给数组追加新的元素
>
>2）参数直接写数组元素即可
>
>3）push完毕之后，返回的结果是新数组的长度
>
>4）原数组也会发生变化
>
>2.unshift();在数组开头添加一个或多个数组元素
>
>1）unshift在数组前边添加新的元素
>
>2）unshift()参数直接写数组元素即可
>
>3）unshift完毕之后，返回的结果是新数组的长度
>
>4）原数组也会发生变化
>
>3.pop();删除数组的最后一个元素，无参数
>
>1）pop删除数组最后一个元素，一次只能删除一个
>
>2）pop()无参数
>
>3）pop完毕之后，返回的结果是删除的那个元素
>
>4）原数组也会发生变化
>
>4.shift();删除数组的第一个元素，无参数
>
>1）shift删除数组第一个元素，一次只能删除一个
>
>2）shift()无参数
>
>3）shift完毕之后，返回的结果是删除的那个元素
>
>4）原数组也会发生变化
>
>##### 数组排序
>
>reverse();翻转
>
>sort();排序，单位数可以，双位数会出现问题
>
>解决方案：
>
>```js
>如：
>var  arr=[13,4,12,5];
>arr.sort(function(a,b){
>return a-b;//升序排序；b-a则是降序排序
>})
>    ```
>
>##### 数组索引的方法
>
>arr.indexOf(13);//13所在的索引号,从前开始查找
>
>注：只返回第一个满足条件的索引号，找不到元素返回的是-1
>
>arr.lastIndexOf(13);//从后边开始查找，找不到返回-1
>
>##### 数组去重案例
>
>```js
>思想：遍历旧数组，拿着旧数组中的元素在新数组中是否存在，不存在的话存进新数组
>function unique(arr){
>var newArry=[];
>for(var i=0;i<arr.length;i+=){
>       if(newArry.indexOf(arr[i])==-1){
>            newArr.push(arr[i]);
>             }
>        }
>     return newArry;
>     }
>    var demo=unique(['a','b','c','a']);
>```
>
>##### 数组转换为字符串
>
>1.toString();逗号分隔每一项，返回一个字符串
>
>arr.toString();
>
>2.join('分隔符');
>
>arr.join('-');以-分隔
>
>##### 其他方法
>
>concat();连接两个多个数组，不影响原数组，返回一个新数组
>
>eg：
>
>```js
>var num1 = [1, 2, 3],
>num2 = [4, 5, 6],
>num3 = [7, 8, 9];
>    
>    var nums = num1.concat(num2, num3);
>```
>
>slice();数组截取slice(begin,end)，返回被截取项的新数组
>
>splice();数组删除splice(第几个开始，删除几个)，返回被删除项目的数组，这个会影响原数组

##### String字符串对象

>基本包装类型；就是把简单数据类型包装成了复杂数据类型
>
>复杂数据类型才会有属性和方法
>
>var  str='andy';
>
>console.log(str.length);
>
>1）把简单数据类型包装成为复杂数据类型
>
>var  temp=new String('andy');
>
>  2）把临时变量的值给str
>
>str=temp;
>
>  3)销毁这个临时变量
>
>temp=null;
>
>  ##### 字符串的不可变性
>
>指的是里边得值没变，虽然看上去可变，只是改变了指向的地址，重新赋值就会新开辟内存空间
>
>##### 字符串方法
>
>字符串所有的方法，都不会修改字符串本身（字符串是不可变的），操作完成会返回一个新的字符串
>
>###### 1.根据字符返回位置
>
>var str='改革春风吹满地';
>
>console.log(str.indexOf('春'))；
>
>console.log(str.indexOf('春'，3))；//从3号位置开始查找
>
>###### 案例：查找字符串“abcoefoxyozzopp"中所有o出现的位置以及次数
>
>1）先查找第一个o出现的位置
>
>2）然后只要indexOf返回的结果不是-1就继续往后查找
>
>3）因为indexOf只能查找到第一个，所以后面的查找，利用第二个参数，当前索引加1，从而继续查找
>
>```js
>var str='abcoefoxyozzopp';
>var index=str.indexOf('o');
>var num=0;
>while(index!==-1){
>num++;
>index=str.indexOf('o',index+1);
>    }
>    ```
>
>###### 2.根据位置返回字符
>
>1.charAt(index)根据位置返回字符
>
>var str='andy';
>
> console.log(str.charAt(3));
>
> 2.charCodeAt(index)根据位置返回位置ASCII码
>
>console.log(str.charCodeAt(0));
>
> 3.str[index]获取指定位置处字符，H5新增
>
>##### 案例：判断一个字符串“abcoefoxyozzopp"中出现次数最多的字符，并统计其次数
>
>1）利用charAt()遍历这个字符串
>
>2）把每个字符都存储给对象，如果对象没有该属性，就为1，如果存在就加1
>
>3）遍历对象，得到最大值和该字符
>
>```js
>var str='abcoefoxyozzopp';
>var o={};
>for(var i=0;i<str.length;i++){
>var chars=str.charAt(i);//chars是字符串的每一个字符
>if(o[chars]){//o[chars]得到的是属性值
>       o[chars]++;
>    }else{
>        o[chars]=1;
>    }
>     }
>    console.log(o);
>//遍历对象
>var max=0;
>var ch='';
>for(var k in o){
>//k是属性名
>//o[k]是属性值
>    if(o[k]>max){
>       max=o[k];
>       ch=k;
>     }
>     }
>    console.log(max);
>console.log('最多的字符是'+ch);
>```
>
>##### 3.字符串的操作方法
>
>1）concat(str1,str2...)连接两个或多个字符串，等同于加号
>
>var  str='andy';
>
> console.log(str.concat('red'));
>
>  2)substr('截取的起始位置','截取几个字符')；
>
>var  str1='改革春风吹满地'；
>
>str1.substr(2,2);//返回  春风
>
>3）替换字符串 raplace('被替换字符','替换为的字符')
>
>var  str='andy';
>
>str.replace('a','b‘);//只会替换第一个字符
>
>###### 案例：将字符串’abcoefoxyozzopp'里面的所有o替换为*
>
>```js
>var str='abcoefoxyozzopp';
>while(str.indexOf('o')!==-1){
>str=str.replace('o','*');
>}
>    console.log(str);
>```
>
>4）字符串转换为数组 split('分隔符')
>
>var  str='red,pink,blue';
>
>console.log(str.split(','));//得到一个数组
>
>5）toUpperCase()//转换成大写
>
>6）toLowerCase()//转换成小写

##### 简单数值类型和复杂引用类型

>1.值类型：简单数据类型/基本数据类型，存储时变量中存的是值本身
>
>string,number,boolean,undefined,null
>
>null:是一个空的对象，想要存储为对象，没有想好放啥
>
>###### 值类型存放在栈里，里面直接开辟一个空间，存的是值
>
>2.复杂类型：变量中存的是地址，通过new关键字创建的对象
>
>###### 复杂类型存放在堆里，首先在栈里边存放一个地址，地址指向堆里的数据
>
>3.二者传递参数的事项
>
>值类型直接改变栈里的值，不会影响其他
>
>复杂类型，是把地址赋值给另一个，所以指向的是同一个地址的值
>
>```js
>function Person(name){
>    this.name=name;
>}
>function f1(x){
>    console.log(x.name);//刘德华
>    x.name='张学友'；
>    console.log(x.name);//张学友
>}
>var p=new Person("刘德华")；
>console.log(p.name);//刘德华
>f1(p);
>console.log(p.name);//张学友
>```
>

## Web APIs

web APIs是w3c组织的标准，主要学习DOM和BOM，主要是页面交互的功能，需要JS基础做铺垫

>API：应用程序编程接口。是一些预定义的函数，完成一些功能，会使用就行
>
>Web  API：是浏览器提供的一套操作浏览器元素和页面元素的API

### DOM

文档对象模型，是W3C组织推荐的处理可扩展语言的标准编程接口

通过DOM可以改变页面的内容、样式或结构

>##### DOM树
>
>1.文档：一个页面就是一个文档，DOM中使用document表示
>
>2.元素：页面中的所有标签都是元素，DOM中使用element表示
>
>3.节点：网页中所有的内容都是节点（标签、属性、文本、注释等），DOM中使用node表示
>
>###### DOM把以上内容都看做对象
>
>因为页面从上往下加载，所以得先有标签，所以script写到标签下面

#### 获取元素

>##### 1.根据标签id获取元素
>
>返回的是元素对象，参数是字符串格式
>
>```js
><div id="timer">2020-6-26</div>
>var time = document.getElementById('timer');
>console.log(time);
>console.dir(time);//打印返回的元素对象，查看里边得属性和方法
>```

>##### 2.根据标签名获取元素
>
>getElementsByTagName()可以返回带有指定标签名的对象的集合
>
>1）返回的是获取过来元素对象的集合，以伪数组的形式存储的
>
>```js
>doucument.getElementsByTagName('li');
>```
>
>2）依次打印里面的元素对象，通过for循环遍历
>
>3）获取的对象是动态的
>
>4）element.getElementsByTagName()得到这个元素里面的某些标签
>
>```js
><div id="nav">
>    <ul>
>       <li></li>
>    </ul>
></div>
>var nav=document.getElementById('nav');
>var navLis=nav.getElementsByTagName('li');
>```

>##### 3.通过HTML5新增获取元素方法
>
>1）document.getElementsByClassName('box');
>
>2）document.querySelector('.box');//返回指定选择器的第一个元素对象，里面的选择器需要加符号
>
>​      document.querySelector('#nav');
>
>3）document.querySelectorAll();返回指定选择器的所有元素对象集合

>##### 4.获取特殊元素
>
>1）获取body元素
>
>document.body;
>
>2）获取html元素
>
>document.documentElement;

#### 事件基础

>事件有三部分组成：事件源、事件类型、事件处理程序；也称为事件三要素
>
>1.事件源：事件被触发的对象
>
>```js
>var btn=document.getElementById('btn');
>```
>
>2.事件类型：如何触发，什么事件，比如点击鼠标、鼠标经过等
>
>3.事件处理程序：通过一个函数赋值的方式完成
>
>```js
>btn.onclick=function(){
>    alert('点我')；
>}
>```

#### 操作元素（核心内容）

>##### 1.改变元素内容
>
>1）element.innerText
>
>2）element.innerHTML
>
>二者的区别：
>
>1）element.innerText不识别html标签，去除html标签，非标准，还会去除空格和换行；而element.innerHTML识别html标签，显示标签，是W3C标准
>
>2）这两个元素是可以读写的，可以获取元素里面的内容
>
>```js
>var p=document.querySelector('p');
>console.log(p.innerHTML);
>```

>##### 2.操作元素的方法来改变属性
>
>```js
><button id="zxy">张学友</button>
><img src="images/ldh.jpg" alt="">
>var zxy=document.getElementById('zxy');
>var img=document.querySelector('img');
>zxy.onclick=function(){
>    img.src='images/zxy.jpg';
>}
>```

>##### 3.改变表单属性的值
>
>```html
><button>按钮</button>
><input type="text" value="输入内容">
><script>
>        var btn = document.querySelector('button');
>        var input = document.querySelector('input');
>        btn.onclick = function() {
>            // 改变表单里面的值
>            input.value = '被点击了';
>            // 按钮被禁用
>            // btn.disabled = true;
>            this.disabled = true; //this是指向事件函数的调用者btn
>        }
></script>
>```
>
>

>##### 4.改变样式属性
>
>一个按钮做两个效果来回切换，需要用flag变量，切换值
>
>1.行内样式
>
>适合样式较少时使用
>
>```js
>element.style.backgroundColor='red';//里边得属性采用驼峰命名法
>```
>
>##### 案例：垂直排放的精灵图图标快速安排到每一个小li
>
>```js
>var lis=document.querySelectorAll('li');
>for(var i=0;i<lis.length;i++){
>    //每个精灵小图标距离都是44px,所以用索引*44正好是小图标的y坐标
>    var index=i*44;
>    lis[i].style.backgroundPosition='0 -'+index+'px';
>}
>```
>
>##### 案例：显示隐藏文本框内容
>
>```js
>var text=document.querySelector('input');
>text.onfocus=function(){
>    if(this.value==='手机'){
>        this.value='';
>    }
>    this.style.color='#333';
>}
>text.onblur=function(){
>    if(this.value===''){
>        this.value='手机';
>    }
>    this.style.color='#999';
>}
>```
>
>2.类名样式操作
>
>适合修改样式较多时
>
>```js
>先声明好一个类，点击后才将该类添加到元素
>var div=document.querySelector('div');
>div.className='change';
>如果没有类名，直接向元素添加；如果原来有类名，会覆盖原来的类名
>解决办法：
>div.className='first change';//写上原来的类名
>```
>
>

#### 一组元素都需要操作（非操作单个元素案例）

>for循环
>
>```js
>var btns=document.getElementsByTagName('button');
>for(var i=0;i<btns.length;i++){
>    btns[i].onclick=function(){
>        for(var i=0;i<btns.length;i++){
>            btns[i].style.backgroundColor='';
>        }
>        this.style.backgroundColor='pink';
>        //先排除其他人，再设置自己的样式，这种思想成为排他思想
>    }
>}
>```
>
>##### 案例：点击图片修改页面的背景图
>
>```js
>var imgs=document.querySelector('.baidu').querySelectorAll('img');
>for(var i=0;i<imgs.length;i++){
>    imgs[i].onclick=function(){
>        document.body.backgroundImage='url('+this.src+')';
>    }
>}
>```
>
>##### 案例：鼠标放在表格某一行，某一行背景变色，离开去掉背景色
>
>```js
>var trs=document.querySelector('tbody').querySelectorAll('tr');
>for(var i=0;i<trs.length;i++){
>    trs[i].onmouseover=function(){
>        this.className='bg';
>    }
>    trs[i].onmouseout=function(){
>        this.className='';
>    }
>}
>```
>
>##### 案例：复选框的全选和取消全选
>
>```js
>//每一行的第一列都是一个input复选框，第一行的id是j_cbAll;tbody的id名是j_tb
>var j_cbAll=document.getElementById('j_cbAll');
>var j_tbs=document.getElementById('j_tb').getElementsByTagName('input');
>//点击全选全选中
>j_cbAll.onclick=function(){
>    for(var i=0;i<j_tbs.length;i++){
>        j_tbs[i].checked=this.checked;
>    }
>}
>//下面的复选框全部选中，上边的全选按钮才会被选中；每次点击复选框，都要遍历每个复选框是否都被选中
>for(var i=0;i<j_tbs.length;i++){
>    j_tbs[i].onclick=function(){
>        //flag控制全选按钮是否被选中
>        var flag=true;
>        //检查其余的复选框是否被选中
>        for(var i=0;i<j_tbs.length;i++){
>            if(!j_tbs[i].checked){//没有被选中
>                flag=false;
>                break;//退出for循环
>            }
>        }
>        j_cbAll.checked=flag;
>    }
>}
>```

#### 获取元素属性值

>1.element.属性//获取自带属性
>
>2.element.getAttribute('属性')//主要获取自定义属性，就是自己添加的属性

#### 设置属性值

>1.element.属性=‘值’；
>
>2.element.setAttribute('属性'，‘值’)；
>
>eg:
>
>```js
>var div=document.querySelector('div');
>div.className='navs';
>div.setAttribute('class','navs');
>```
>
>3.移除属性
>
>removeAttribute(属性)；

#### Tab栏切换案例

>```js
>var tab_list=document.querySelector('.tab_list');
>var lis=tab_list.querySelectorAll('li');
>var items=document.querySelectorAll('.item');//获取所有的内容模块
>for(var i=0;i<lis.length;i++){
>    //给li设置索引号
>    lis[i].setAttribute('index',i);
>    lis[i].onclick=function(){
>        1.上边的选项卡，在类名为tab_list中有ul列表
>        //排他思想
>        for(var i=0;i<lis.length;i++){
>            lis[i].className='';
>        }
>        this.className='current';//li的背景色变红 
>        2.下边的显示内容
>        //核心思想：给上面的tab_list中的每一个li添加指定以熟悉，属性值从0开始
>        var index=this.getAttribute(index);
>        for(var i=0;i<items.length;i++){
>            items[i].style.display='none';
>        }
>        items[index].style.display='block';
>    }
>}
>```
>
>

#### H5自定义属性

>目的：是为了保存并使用数据，有些数据保存到页面不用保存到数据库
>
>注意：防止自定义属性的歧义，H5规定自定义属性以data-开头作为属性并赋值
>
>eg：<div data-index="1"></div>
>
>也可以通过setAttribute来设置，通过getAttribute来获取
>
>##### H5新增获取自定义属性的方法(ie11以下有问题)
>
>div.dataset.index或者data.dataset['index']
>
>dataset是一个集合，里面存放了所有以data开头的自定义属性
>
>注意：
>
>```html
><div data-list-name="andy"></div>
>//获取有多个-连接的单词时，我们采取驼峰命名法
>div.dataset.listName;
>div.dataset['listName'];
>```

#### 节点操作

利用父子兄弟节点关系获取元素，逻辑性强，但兼容性较差

组成：一般情况下，节点至少拥有nodeType(节点类型)、nodeName(节点名称)和nodeValue(节点值)这三个基本属性

元素节点nodeType是1；属性节点nodeType是2；文本节点nodeType是3（包括文字、空格、换行等）

注：主要操作的是元素节点

节点层级：常见的是父子兄节点

##### 1.父节点

node.parentNode;得到的是离元素最近的父节点，亲爸爸

```js
var div=document.querySelector('div');
div.parentNode;
```

##### 2.子节点

>1.获取ul中的li
>
>```js
>var ul=document.querySelector('ul');
>ul.chidNodes;//得到所有的子节点，包括文本节点和元素几点
>//只获得元素节点，1.通过判断nodeType
>//2.通过children
>ul.children;//推荐，非标准属性，无兼容性问题
>```
>
>##### 2.获取第一个子节点
>
>ol.firstChild;//包括元素、文本等节点
>
>ol.firstElementChild;//获取第一个子元素节点，但有兼容性问题，是ie9以上
>
>ol.children[0];//实际开发中，无兼容性问题
>
>##### 3.获取最后一个子节点
>
>同第一个一样
>
>ol.children[ol.children.length-1];//开发中

##### 3.兄弟节点(用的较少)

```js
<div></div>
<span></span>

var div=document.querySelector('div');
console.log(div.nextSibling);//下一个兄弟（包括元素、文本）
console.log(div.previousSibling);//上一个兄弟几点
//只获得元素节点，但兼容性不好
console.log(div.nextElementSibling);
console.log(div.previousElementSibling);
解决办法：自己封装兼容性函数，利用nodeType
```

##### 4.创建节点

```js
var li=document.createElement('li');
//添加节点
var ul=document.querySelector('ul');
ul.appendChild(li);//在最后边追加元素，不会覆盖原来的
```

##### 5.添加节点insertBefore(child,指定元素)

```js
ul.insertBefore(li,ul.children[0]);
```

##### 6.删除节点

>node.removeChild(child);//删除父节点中的某一个子节点
>
>```js
>var ul=document.querySelector('ul');
>var btn=document.querySelector('button');
>
>//点击按钮依次删除里面的孩子
>btn.onclick=function(){
>    if(ul.children.length==0){
>        this.disabled=true;
>    }else{
>        ul.removeChild(ul.children[0]);
>    }
>}
>```
>
>

##### 7.复制节点（克隆）

>node.cloneNode()方法返回调用该 方法的节点的一个副本，也称为克隆节点/拷贝节点
>
>```js
>var ul=document.querySelector('ul');
>var li=ul.children[0].cloneNode(true);
>ul.appendChild(li);
>```
>
>注：1.如果括号参数为空或者false，则是浅拷贝，即只是克隆复制节点本身，不克隆里边的子节点
>
>2.括号里为true，深拷贝，复制标签里的内容

#### 三种创建元素的区别

>1.document.write()创建元素，如果页面文档流加载完毕，再调用这句话会导致页面重绘
>
>2.innerHTML创建元素
>
>```js
>var inner=document.querySelector('.inner');
>//效率低，速度，慢，因为每连接一个字符串，都会开辟一个空间
>for(var i=0;i<=100;i++){
>    inner.innerHTML+='<a href="#">百度</a>'
>}
>//采用数组存储，再显示，效率高
>var arr=[];
>for(var i=0;i<=100;i++){
>    arr.push('<a href="#">百度</a>');
>}
>inner.innerHTML=arr.join('');
>```
>
>3.document.createElement()创建元素
>
>```js
>var inner=document.querySelector('.inner');
>for(var i=0;i<=100;i++){
>    var a=document.createElement('a');
>    create.appendChild(a);
>}
>```
>
>总结：innerHTML创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂；createElement()创建多个元素效率稍微低一点点，但是结构更清晰
>
>##### 不同浏览器下，innerHTML效率比createElement()更高

#### 下拉菜单案例（采取节点方式）

>//布局
>
>```html 
><ul class="nav">
>    <li>
>        <a>微博</a>
>        <ul>
>            <li><a>私信</a></li>
>        </ul>
>    </li>
></ul>
>```
>
>```js
>var nav=document.querySelector('.nav');
>var lis=nav.children;
>//循环注册
>for(var i=0;i<lis.length;i++){
>    lis[i].onmouseover=function(){
>        this.children[1].style.display='block';
>    }
>    lis[i].onmouseout=function(){
>        this.children[1].style.display='none';
>    }
>}
>```

#### 简单发布、删除留言板的案例

>核心思路：点击按钮之后，就动态创建一个li，添加到ul里面
>
>通过innerHtml显示添加的内容
>
>通过appendChild或insertBefore来添加

```js
<textarea name="" id="">123</textarea>
<button>发布</button>
<ul></ul>
//1.获取元素
var btn=document.querySelector('button');
var text=document.querySelector('textarea');
var ul=document.querySelector('ul');
//2.注册事件
btn.onclick=function(){
    if(text.value==''){
        alert('没有输入内容')；
        return false;
    }else{
        //创建元素
        var li=document.createElement('li');
        li.innerHTML=text.value+"<a href='javascript:;'>删除</a>";
        //添加元素
        //ul.appendChlid(li);
        ul.insertBefore(li,ul.children[0]);
        //删除元素
        var as=document.querySelectorAll('a');
        for(var i=0;i<as.length;i++){
            as[i].onclick=function(){
                ul.removeChild(this.parentNode);
            }
        }
    }
}
```

#### 动态生成表格案例

```html
<body>
    <table cellspacing="0">
        <thead>
            <tr>
                <th>姓名</th>
                <th>科目</th>
                <th>成绩</th>
                <th>操作</th>
            </tr>
        </thead>
        <tbody></tbody>
    </table>
    <script>
        // 先去准备好学生的数据
        var datas = [{
            name: '魏璎珞',
            subject: 'javaScript',
            score: 100
        }, {
            name: '宏利',
            subject: 'javaScript',
            score: 98
        }, {
            name: '傅恒',
            subject: 'javaScript',
            score: 10
        }, {
            name: '名誉',
            subject: 'javaScript',
            score: 88
        }];
        var tbody = document.querySelector('tbody');
        for (var i = 0; i < datas.length; i++) {
            // 创建行
            var tr = document.createElement('tr');
            tbody.appendChild(tr);
            // 行里创建单元格，数量取决于每个对象里的属性个数
            for (var k in datas[i]) {
                //创建单元格
                var td = document.createElement('td');
                // 把对象里的属性值给td
                td.innerHTML = datas[i][k];
                tr.appendChild(td);
            }
            // 创建有删除两个字的单元格
            var td = document.createElement('td');
            td.innerHTML = '<a href="javascript:;">删除</a>';
            tr.appendChild(td);
        }
        //删除操作
        var as = document.querySelectorAll('a');
        for (var i = 0; i < as.length; i++) {
            // 点击a删除a的父亲的父亲
            as[i].onclick = function() {
                tbody.removeChild(this.parentNode.parentNode);
            }
        }
    </script>
</body>
```

#### 高级事件

给元素添加事件，称为注册事件或绑定事件

注册事件有两种方式：传统方式和方法监听注册方式

>1.传统方式：利用on开头的事件，如onclick
>
>1）特点：注册事件的唯一性
>
>2）同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数
>
>2.方法监听注册方式
>
>1）w3c标准推荐方式
>
>2）addEventListener()他是一个方法
>
>3）ie9之前的ie不支持此方法，可使用attachEvent()代替
>
>4）同一个元素同一个事件可以注册多个监听函数
>
>5）按注册顺序依次执行

##### 绑定事件

>###### eventTarget.addEventListener(type,listener[,useCapure])
>
>type:事件类型字符串，如click、mouseover，注意这里不要带on
>
>listener：事件处理函数，事件发生时，会调用该监听函数
>
>useCapture:可选参数，是一个布尔值，默认是false

```js
var btns=document.querSelectorAll('button');
btns[1].addEventListener('click',function(){
    alert(22);
})
```

```js
//attachEvent是ie9以前的版本支持，一般不使用
btns[1].attachEvent('onclick',function(){
    alert(88);
})//只有这两个参数，第一个要带on
```

##### 删除事件（解绑事件）

>1.传统方式
>
>div[0].onclick=null;
>
>2.监听事件（不能用匿名函数了）
>
>```js
>btns[1].addEventListener('click',fn);
>function fn(){
>    alert(00);
>    btns[1].removeEventListener('click',fn);
>}
>```
>
>3.detachEvent（ie9以下）
>
>```js
>btns[1].attachEvent('onclick',fn);
>function fn(){
>    alert(00);
>    btns[1].detachEvent('onclick',fn);
>}
>```

##### DOM事件流

事件流描述的是从页面中接受事件的顺序

事件发生时会在元素节点之间按照待定的顺序传播，这个传播过程即DOM事件流。

>###### DOM事件流3个阶段：
>
>1.捕获阶段:document-html-bodt-div(IE最早提出)，点击子元素，由外到内触发事件
>
>2.当前目标阶段
>
>3.冒泡阶段：div-body-html-document(网景最早提出)，点击子元素，由内到外触发事件

>##### 注意：
>
>1.JS代码中只能执行捕获或者冒泡中的一个阶段
>
>2.onclick和attachEvent只能得到冒泡阶段
>
>3.addEventListener第三个参数是true，则表示是在事件捕获阶段；如果是false，默认是false，表示在冒泡阶段
>
>4.实际开发中更关注事件冒泡
>
>5.有些事件是没有冒泡的，如：onblur、onfocus、onmouseenter、onmouseleave
>
>6.事件冒泡有利有弊

##### 事件对象

>div.onclick=function(event){}
>
>1.event就是一个事件对象，监听函数的形参
>
>2.事件对象只有事件才会存在，是系统自动创建的，不需要传递参数
>
>3.事件对象是我们事件的一系列相关数据的集合，跟事件相关的，如鼠标点击的鼠标坐标，键盘用户按下的哪个键
>
>4.这个事件对象可以自己命名，如e
>
>5.事件对象兼容性问题，ie678通过window.event获取，兼容的做法，e=e||window.event，可直接获取e

##### 事件对象的常用属性和方法

>1.e.target：触发事件的对象（元素），this返回的是绑定事件的对象（元素）
>
>```js
>var ul=document.querySelector('ul');
>ul.addEventListener('click',function(e){
>    console.log(this);//绑定的是ul，返回ul
>    console.log(e.target);//我们点击的是li，返回li
>})
>```
>
>ie678用的是e.srcElement
>
>2.了解   e.currentTarget和this的作用一样
>
>3.返回事件类型:e.type
>
>4.阻止默认行为，连接跳转不跳转，提交按钮不提交
>
>e.preventDefault();//传统注册和addEventListener都能用，dom标准
>
>e.returnValue;//传统注册方式ie678识别
>
>return false;//只能用于传统方式，无兼容性问题，但其后的代码不能执行了
>
>##### 5.阻止冒泡
>
>点击谁就触发谁的事件
>
>e.stopPropagation();//dom推荐的标准
>
>e.cancelBubble=true;//非标准，低版本

##### 事件委托（代理、委派）

>事件冒泡本身的特性，冒泡带来的好处
>
>原理：不是给每一个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响每一个子节点
>
>###### 如：给ul注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击li，事件会冒泡到ul，ul有注册事件，就会触发事件监听器
>
>事件委托的作用：
>
>只操作一次DOM，提高程序的性能

##### 常用的鼠标事件

>1.onclick
>
>2.onmouseover
>
>3.onmouseout
>
>4.阻止鼠标右键：contextmenu，函数中用preventDefault()
>
>5.阻止选择文字：selectstart，函数中用preventDefault()

##### 鼠标事件对象(MouseEvent)

```js
document.addEventListener('click',function(e){
    console.log(e.clientX);//鼠标坐标x轴，相对于可视区,拖动滚动条不会变
    console.log(e.clientY);//鼠标坐标y轴
    console.log(e.pageX);//鼠标坐标x轴，相对于页面文档，拖动滚动条会变，ie9+,还有pageY
})
```

##### 案例：图片跟随鼠标移动

>给document注册事件，图片采用绝对定位，不占有位置
>
>```js
>var pic=document.querySelector('img');
>document.addEventListener('mousemove',function(){
>    //mousemove移动1px就会触发这个事件
>    //每次移动都会重新获得鼠标坐标
>    var x=e.pageX;
>    var y=e.pageY;
>    //不要忘记加单位
>    pic.style.top=y-40+'px';//减去图片的一半，让鼠标留在图片中间
>    pic.style.left=x-40+'px';
>})
>```
>
>

##### 常用的键盘事件

>1.onkeyup:按键弹起触发
>
>2.onkeydown:按键按下触发，会把按的值写进输入框
>
>3.onkeypress:按键按下触发（不能识别功能键，shift,ctrl,左右箭头）
>
>三个都写的顺序：onkeydown-onkeypress-onkeyup

##### 键盘事件对象

>1.e.keyCode:键盘的ASCII码值
>
>注：1）keyup和keydown事件不区分大小写，a和A都是65
>
>2）keypress区分大小写，a是97，A是65

##### 案例：按下s键光标定入到input输入框

```js
var search=document.querySelector('input');
document.addEventListener('keyup',function(e){
    if(e.keyCode===83){
        search.focus();
    }
})
```

##### 案例：模拟京东快递单号

>当我们在文本框输入内容时，文本框上面自动显示大字号的内容
>
>```html
>    <div class="search">
>        <div class="con">123</div>
>        <input type="text" placeholder="请输入快递单号" class="jd">
>    </div>
>    <script>
>        var con = document.querySelector('.con');
>        var jd_input = document.querySelector('.jd');
>        jd_input.addEventListener('keyup', function() {//keydown和keypress在文本框里的特点：他们两个事件触发时，文字还没有落入文本框；keyup触发时，文字已经落入文本框
>            if (this.value == '') {
>                con.style.display = 'none';
>            } else {
>                con.style.display = 'block';
>                con.innerHTML = this.value;
>            }
>        })
>         // 失去焦点上边盒子隐藏
>        jd_input.addEventListener('blur', function() {
>                con.style.display = 'none';
>            })
>            // 获得焦点，显示盒子
>        jd_input.addEventListener('focus', function() {
>            if (this.value !== '') {
>                con.style.display = 'block';
>            }
>        })
>    </script>
>```

### BOM

1.浏览器对象模型，提供了独立于内容而与浏览器窗口进行交互的对象，核心对象是window

window:是浏览器的顶级对象，有双重角色

1）它是JS访问浏览器窗口的一个接口

2）它是浏览器的一个全局对象，定义在全局作用域的变量和函数都会变成window对象的属性和方法

3）在调用的时候可以省略window

注意：window下的一个特殊属性window.name

2.BOM缺乏标准，JavaScript语法的标准是ECMA，DOM的标准化组织是W3C，BOM最初是Netscape浏览器标准的一部分

兼容性较差

3.BOM比DOM大，BOM包含DOM

#### window对象常见的事件

##### 窗口加载事件

>1.window.onload是窗口（页面）加载事件，当文档内容完全加载才会触发该事件（包括图像、脚本文件、CSS等）
>
>window.onload=function(){}或
>
>window.addEventListener('load',function(){});
>
>有了它们就可以把js代码写在页面元素的上面，传统方式只能写一次，多个会以最后一次的为准，而事件监听没有限制
>
>2.DOMContentLoaded(ie9以上才支持)
>
>document.addEventListener('DOMContentLoaded',function(){});
>
>它比onload加载快，因为它仅当DOM加载完成，不包括样式表、图片等就会触发事件
>
>图片较多时，为不影响用户体验，使用它比较合适

##### 调整窗口大小事件

```js
window.onresize=function(){}
window.addEventListener('resize',function(){
    console.log(window.innerWidth);//浏览器窗口宽度
    if(window.innerWidth<=800){
        div.style.display='none';
    }else{
        div.style.display='block';
    }
})
只要窗口大小发生变化，就会触发这个事件，经常用它做响应式布局
```

#### 定时器

>##### 1.setTimeout()
>
>window.setTimeout(调用函数，[延迟的毫秒数])//时间到了调用函数
>
>```js
>var timer=setTimeout(function(){
>    console.log('时间到了');
>},2000);//毫秒省略，默认是0
>//也可以直接写函数名
>var timer=setTimeout(callback,2000);//callback是函数名
>var timer2=setTimeout('callback()',2000);//不推荐使用
>```
>
>因为定时器可能有很多，所以经常给定时器赋值一个标识符，timer1、timer2
>
>1）里面调用的这个函数我们也称为是回调函数callback。
>
>2）普通函数是按照代码顺序直接执行的，回调函数是做完某件事再执行的函数
>
>2.停止定时器，清除定时器
>
>window.clearTimeout(timeoutID);//timeoutID是定时器的标识符
>
>```js
>btn.addEventListener('click',function(){
>    clearTimeout(timer);
>})
>```
>
>##### 3.setInterval()
>
>window.setInterval(回调函数，[延迟的毫秒数])//时间到了调用函数
>
>函数调用同setTimeout();
>
>执行过程不同：setInterval()方法重复调用一个函数，每隔这个时间都会调用一次回调函数
>
>4.clearInterval()

##### 京东倒计时案例

```html
    <div>
        <span class="hour"></span>
        <span class="minute"></span>
        <span class="second"></span>
    </div>
    <script>
        var hour = document.querySelector('.hour');
        var minute = document.querySelector('.minute');
        var second = document.querySelector('.second');
        var input = +new Date('2020-6-28 14:30:00');
        countDown(); //先调用一次这个函数，防止第一次刷新有空白
        //开启定时器
        setInterval(countDown, 1000)

        function countDown() {
            var nowTime = +new Date();

            var times = (input - nowTime) / 1000; //剩余时间的总秒数
            var h = parseInt(times / 60 / 60 % 24); //小时
            h = h < 10 ? '0' + h : h;
            hour.innerHTML = h;
            var m = parseInt(times / 60 % 60); //分
            m = m < 10 ? '0' + m : m;
            minute.innerHTML = m;
            var s = parseInt(times % 60); //秒
            s = s < 10 ? '0' + s : s;
            second.innerHTML = s;
        }
    </script>
```

##### 案例：开启停止定时器

```js
var timer=null;
begin.addEventListener('click',function(){
    timer=setInterval(function(){
        console.log('pp');
    },1000);
})
end.addEventListener('click',function(){
   clearInterval(timer);
})
```

##### 案例：发送短信按钮倒计时

```html
    手机号码：<input type="number"> <button>发送</button>
    <script>
        var btn = document.querySelector('button');
        var time = 5;
        btn.addEventListener('click', function() {
            btn.disabled = true;
            var timer = setInterval(function() {
                if (time == 0) {
                    clearInterval(timer);
                    btn.disabled = false;
                    btn.innerHTML = '发送';
                    time = 5; //重新开始
                } else {
                    btn.innerHTML = '还剩下' + time + '秒';
                    time--;
                }
            }, 1000);
        })
    </script>
```

##### this指向问题

>一般情况下，this的最终指向是那个调用他的对象
>
>1.全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）
>
>2.方法调用中谁调用this指向谁
>
>3.构造函数中this指向构造函数中的实例

#### JS执行机制

>JavaScript语言的一大特点就是单线程，就是，同一时间只能做一件事。
>
>代码会按顺序执行，如果一段代码执行时间过长，会影响下边代码的执行，为解决这个问题，利用多核cpu的计算功能，HTML5提出了Web Worker，允许JS创建多个线程
>
>同步：单线程
>
>异步：多线程
>
>同步任务：同步任务都在主线程上执行，形成一个执行栈
>
>异步任务：JS的异步是通过回调函数实现的。一般，异步任务有以下三类
>
>1.普通事件：click、resize等
>
>2.资源加载：load、error等
>
>3.定时器：setInterval、setTimeout等
>
>###### 异步任务相关的回调函数添加到任务队列中（也称消息队列）
>
>##### 执行过程：
>
>1.先执行执行栈中的同步任务
>
>2.异步任务（回调函数）放入任务队列中，只有触发了异步任务，异步进程处理才会将其放到任务队列
>
>3.一旦执行栈中的同步任务执行完毕，系统将会按顺序读取任务队列中的异步任务，进入执行栈，开始执行
>
>###### 由于主线程不断重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环

#### location对象

location对象是window对象的一个属性，用于获取或设置窗体的URL，并且可用于解析URL，这个属性返回的是一个对象，因此叫location对象

URL：统一资源定位符，互联网的每个文件都有唯一一个URL

>常见属性：
>
>href、host、port、pathname(返回路径)、search(返回参数)、hash（返回连接锚点）
>
>方法：
>
>location.assign();跟href一样，可以跳转页面（重定向页面）
>
>location.replace();替换当前页面，不记录历史，不能后退
>
>location.reload();重新加载页面，相当于刷新或者f5，如果参数为true，强制刷新ctrl+f5

#### navigator对象

>userAgent属性：检测什么浏览器显示不同的页面

#### history对象

>1.back();
>
>2.forward();//前进
>
>3.history.go();//参数写几步

### pc端网页特效

#### 元素偏移量offset

>使用offset系列相关属性可以动态得到该元素的位置（偏移）、大小等
>
>1.获得元素距离带有定位的父元素的位置,否则以body为准
>
>element.offsetTop
>
>element.offsetLeft
>
>2.获得元素自身的大小（宽度高度），包括padding、border、width
>
>element.offsetWidth
>
>element.offsetHeight
>
>3.返回带有定位的父亲，如果没有返回body
>
>element.offsetParent
>
>4.注意：返回的数值都不带单位

#### offset与style的区别

>1.style只能获得行内样式表的样式
>
>2.style获得的是带有单位的字符串类型，offset是没有单位的数值
>
>3.style是不包含padding、border的
>
>4.style是读写属性，offset是只读属性
>
>总结：想要获取元素大小位置用offset，要想给元素更改值，则需要用style

#### 案例：获取鼠标在盒子内的坐标

```html
    <div class="box"></div>
    <script>
        var box = document.querySelector('.box');
        box.addEventListener('mousemove', function(e) {
            var x = e.pageX - this.offsetLeft;
            var y = e.pageY - this.offsetTop;
            this.innerHTML = 'x坐标是' + x + 'y坐标是' + y;
        })
    </script>
```

#### 案例：模态框拖拽

```js
//点击弹出层这个链接link，让mask和login显示出来
link.addEventListener('click',function(){
    mask.style.display='block';
    login.style.display='block';
})
//点击closeBtn就隐藏mask和login
closeBtn.addEventListener('click',function(){
    mask.style.display='none';
    login.style.display='none';
})
//开始拖拽
//当鼠标按下时，就获得鼠标在盒子内的坐标
title.addEventListener('mousedown',function(e){
    var x=e.pageX-login.offsetLeft;
    var y=e.pageY-login.offsetTop;
    //鼠标移动的时候，用鼠标在页面中的坐标减去鼠标在盒子内的坐标就是模态框的left和top
    document.addEventListener('mousemove',move);
    function move(e){
        login.style.left=e.pageX-x+'px';
        login.style.top=e.pageY-y+'px';
    }
    //鼠标松开，接触移动事件
    document.addEventListener('mouseup',function(e){
        removeEventListener('mousemove',move);
    });
})
```

25-29还没看

## JavaScript高级（含ES6）

### 面向对象

>两大编程思想：
>
>1.面向过程（POP）：就是分析出解决问题所需要的的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个一次调用
>
>优点：性能比面向对象高，适合跟硬件联系很密切的东西，例如单片机就采用的是面向过程编程
>
>缺点：没有面向对象易维护、易复用、易扩展
>
>2.面向对象（OOP)：把事务分解成一个个对象，然后由对象之间分工与合作
>
>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护
>
>缺点：性能比面向对象过程低
>
>##### 面向对象是以对象功能来划分问题，而不是步骤
>
>面向对象每一个对象都是功能中心，分工明确，面向对象编程具有灵活性、代码可复用、容易维护和开发的优点，适合多人合作大型软件项目
>
>面向对象特性：
>
>1.封装性
>
>2.继承性
>
>3.多态性

### ES6中的类和对象

可以使用面向对象描述现实世界事务，但事物分为具体的事物和抽象的事物

面向对象的思维特点：

1.抽取（抽象）对象共用的属性和行为组织（封装）成一个类（模板）

2.对类进行实例化、获取类的对象

面向对象编程我们考虑的是有哪些对象，按照对象思维特点，不断的创建对象，使用对象

>###### 1.对象
>
>对象是一个具体的事物，在JS中，对象是一组无序的相关属性（特征）和方法（行为）的集合，所有的事物都是对象
>
>###### 2.类
>
>类抽象了对象的公共部分，它泛指某一大类；对象是特指某一个，通过类实例化一个具体对象

#### 创建类

```js
class name{
    //class body
}
创建实例
var xx=new name();
类必须使用new 实例化对象
```

eg:

```js
class Star{
    constructor(uname,age){
        this.name=name;
        this.age=age;
    }
}
var ldh=new Star('刘德华',18);
console.log(ldh);
```

>##### 注意：
>
>1.通过class关键字创建类，类名习惯首字母大写
>
>2.类里面有一个 constructor函数，可以接受传递过来的参数，同时返回实例对象
>
>3.constructor函数只要new生成实例时，就会自动调用这个函数，如果我们不懈这个函数，类也会自动生成这个函数
>
>4.生成实例new 不能省略
>
>5.语法规范：创建类，类名后面不加小括号，生成实例，类名后加小括号，构造函数不需要加function

#### 类中添加方法

```js
class Star{
    sing(){
        console.log('唱歌')；
    }
}
var ldh=new Star();
ldh.sing();
//1.类里面的所有函数不需要写function
//2.多个函数方法之间不需要添加逗号
```

#### 类的继承

继承父类的属性和方法

```js
class Father{
    constructor(x,y){
        this.x=x;
        this.y=y;
    }
    sum(){
        console.log(this.x+this.y);
    }
}
class Son extends Father{
    constructor(x,y){
        super(x,y);//调用了父类中的构造函数
    }
}
var son=new Son(1,2);
son.sum();//3
```

#### super关键字

>super关键字用于访问和调用对象父类上的函数。可以调用父类上的构造函数，也可以调用父类的普通函数
>
>```js
>class Father{
>    say(){
>        return '父亲';
>    }
>}
>class Son extends Father{
>    say(){
>        //return '儿子';
>        console.log(super.say());//父亲
>    }
>}
>var son=new Son();
>//son.say();//儿子
>son.say();//父亲
>注：
>继承中的属性或方法查找原则：就近原则
>实例化子类，先看子类有没有该方法，如果有就执行，没有就像父类继续寻找
>```

#### 子类继承父类

```js
class Father{
    constructor(x,y){
        this.x=x;
        this.y=y;
    }
    sum(){
        console.log(this.x+this.y);
    }
}
class Son extends Father{
    constructor(x,y){
        super(x,y);//调用了父类中的构造函数,super必须写在子类this之前调用
        this.x=x;
        this.y=y;
    }
    subtract(){
         console.log(this.x-this.y);
    }
}
var son=new Son(5,3);
son.subtract();//2
son.sum();//8
```

#### 三个注意点

>1.在ES6中没有变量提升，所以必须先定义类，才能通过类实例化对象，实例化代码写在创建类后边。
>
>2.类里面的共有属性和方法一定要加this使用
>
>3.类中this的指向
>
>1）constructor里面的this指向的是实例对象
>
>2）方法里面的this指向这个方法的调用者
>
>```js
><button>点击</button>
>var that;
>class Father{
>    constructor(x,y){
>        that=this;
>        this.x=x;
>        this.y=y;
>        this.sum();//30
>        this.btn=document.querySelector('button');
>        this.btn.onclick=this.sum;//undefined，因为this.btn中无此方法
>    }
>    sum(){
>        console.log(this.x+this.y);
>        console.log(that.x+that.y);//this.btn。onclick就不会返回undefined，返回30；that指向了实例对象
>    }
>}
>var father=new Father(20,10);
>```
>
>

#### Tab栏切换案例

>功能需求：
>
>1.点击tab栏可以切换效果
>
>2.点击+号，可以添加tab项和内容项
>
>3.点击x号，可以删除当前的tab项和内容项
>
>4.双击tab项文字或者内容项文字，可以修改里边得文字内容

>抽象对象：
>
>1.该对象具有切换功能
>
>2.该对象具有添加功能
>
>3.该对象具有删除功能
>
>4.该对象具有修改功能

```js
var that;
class Tab {
    constructor(id) {
            that = this;
            this.main = document.querySelector(id);
            // li的父元素
            this.ul = this.main.querySelector('.fisrstnav ul:first-child');
            // section的父元素
            this.tabson = this.main.querySelector('.tabscon');
            this.add = this.main.querySelector('.tabadd');
            this.init();
        }
        // 初始化函数
    init() {
            this.updateNode();
            this.add.onclick = this.addTab;
            for (var i = 0; i < this.lis.length; i++) {
                this.lis[i].index = i;
                this.lis[i].onclick = this.toggleTab;
                this.remove[i].onclick = this.removeTab;
                this.spans[i].ondblclick = this.editTab;
                this.sections[i].ondblclick = this.editTab;
            }
        }
        // 动态获取所有的动态数量的标签
    updateNode() {
            this.lis = this.main.querySelectorAll('li');
            this.sections = this.main.querySelectorAll('section');
            this.remove = this.main.querySelectorAll('.icon-guanbi');
            this.spans = this.main.querySelectorAll('.fisrstnav li span:first-child');
        }
        // 1.切换功能
    toggleTab() {
        that.clearClass();
        this.className = 'liactive';
        that.sections[this.index].className = 'conactive';
    }
    clearClass() {
            for (var i = 0; i < this.lis.length; i++) {
                this.lis[i].className = '';
                this.sections[i].className = '';
            }
        }
        // 2.添加功能
    addTab() {
            that.clearClass();
            // 用传统的createElement创建元素，但元素里内容较多时，需要innerHTML赋值，再用appendChild追加，
            // insertAdjacentHTML可直接将字符串添加到父元素
            // (1)创建li元素和section元素
            var li = ' <li class="liactive"><span>测试1</span><span class="iconfont icon-guanbi"></span></li>';
            var section = '<section class="conactive">测试1</section>';
            // （2）把这两个元素追加到对应的父元素里面
            that.ul.insertAdjacentHTML('beforeend', li);
            that.tabson.insertAdjacentHTML('beforeend', section);
            that.init();
        }
        // 3.删除功能
    removeTab(e) {
            e.stopPropagation(); //阻止冒泡，防止触发li的切换点击事件
            var index = this.parentNode.index;
            console.log(index);
            // 根据索引号删除对应的li和section，remove方法可以直接删除指定元素
            that.lis[index].remove();
            that.sections[index].remove();
            that.init();
            // 当删除的是非选中状态的按钮时，原来的选中状态不变
            if (document.querySelector('.liactive')) return;
            // 当删除选中状态按钮时，让他的前一个li处于选定状态
            index--;
            // 手动调用点击事件，不需要鼠标触发
            that.lis[index] && that.lis[index].click();

        }
        // 4.修改功能
    editTab() {
        var str = this.innerHTML;
        // 双击禁止选中文字
        window.getSelection ? window.getSelection().removeAllRanges : document.selection.empty();
        this.innerHTML = '<input type="text"></input>';
        var input = this.children[0];
        input.value = str;
        input.select(); //文本框离得文字处于选中状态
        // 当我们离开文本框时，就把文本框里面的值给了span
        input.onblur = function() {
                this.parentNode.innerHTML = this.value;
            }
            // 当我们键盘按下回车时，也可以修改文字
        input.onkeyup = function(e) {
            if (e.keyCode === 13) {
                this.blur();
            }
        }
    }
}
new Tab('#tab');
```

### 构造函数和原型

ES6之前无类的概念，用的都是构造函数和原型

>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋值，总与new一起使用，我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里。
>
>new在执行时会做的四件事：
>
>1.在内存中创建一个新的空对象
>
>2.让this指向这个新的对象
>
>3.执行构造函数里的代码，给这个新对象添加属性和方法
>
>4.返回这个新对象（所以构造函数里面不需要return）

#### 实例成员和静态成员

>1.实例成员就是构造函数内部通过this添加的成员就是实例成员
>
>实例成员只能通过实例化的对象来访问
>
>2.静态成员：在构造函数本身上添加的成员，就是静态成员
>
>Star.sex='男'；//Star是构造函数
>
>静态成员只能通过构造函数来访问

#### 原型prototype

构造函数存在的问题：其中的成员函数不用每次实例化对象都开辟内存空间，要共享

>构造函数通过原型分配的函数是所有对象所共享的
>
>每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有
>
>总结：我们可以把那些不变的方法，直接定义在prototype对象上，这样实例化的所有对象都可以共享这些方法
>
>```js
>Star.prototype.sing=function(){
>    console.log('唱歌')；
>}//Star是构造函数
>var ldh=new Star('刘德华'，18);
>var zxy=new Star('张学友'，19);
>ldh.sing===zxy.sing;//true
>```
>
>一般情况下，我们公共属性定义到构造函数里面，公共的方法放到原型对象上

#### 对象原型

对象都有一个___proto___属性，指向我们构造函数的原型对象

>ldh._proto_===Star.prototype;//true
>
>方法的查找规则：首先先看ldh对象本身是否有sing方法，如果有就执行这个对象上的sing，如果没有就通过对象的__proto__去构造函数原型对象prototype身上去找

#### constructor构造函数

>对象原型和构造函数（prototype）原型对象里面都有一个属性constructor属性，我们称他为构造函数，因为它指回构造函数本身
>
>constructor指的是引用了哪个构造函数
>
>很多情况下，我们需要手动的利用constructor这个属性返回原来的构造函数
>
>```js
>Star.prototype.move=function{}//在原来的基础上添加
>Star.prototype={
>    //如果我们修改了原来的原型对象，给原型对象赋值的是一个对象，则必须手动的利用constructor
>    constructor:Star,
>    sing:function(){}
>}//覆盖了原来的原型，没有了引用的构造函数，需要手动添加
>```

#### 构造函数、实例和原型对象三者之间的关系

![](前端学习.assets/1594532654(1).png)

#### 原型链

<img src="前端学习.assets/1594533018(1).png" style="zoom: 80%;" />

#### JS的成员查找机制

>1.先查找对象本身
>
>2.查找对象的原型（就是——proto——指向的prototype原型对象）
>
>3.查找原型对象的原型（Object的原型对象）
>
>4.依次类推一直找到Object为止（null）
>
>5.——proto——为对象成员查找机制提供一个方向
>
>注：如果都有此成员，以实例对象为准，就近原则

#### 原型对象this指向

>构造函数中的this和原型对象中的this指向的都是实例对象

#### 拓展内置对象

>比如给数组对象添加一个sum方法
>
>```js
>Array.prototype.sum=function(){
>    var sum=0;
>    for(var i=0;i<this.length;i++){
>        sum+=i;
>    }
>    return sum;
>}//添加函数时不能用对象的形式，这样会覆盖以前的函数
>```

### 继承

ES6之前没有提供extends继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承

#### call()

>调用这个函数，并且修改函数运行时的this指向
>
>fun.call(thisArg,arg1,arg2...)
>
>thisArg:当前调用函数this的指向对象
>
>arg1,arg2：传递的其他参数

```js
function fn(x,y){
    console.log(this);//o
    console.log(x+y);//3
}
var o={
    name:'andy'
}
fn.call(o,1,2);//改变这个函数的this指向为o，传递参数1和2
```

#### 借用构造函数继承父类中的属性

```js
function Father(uname,age){
    this.uname=uname;
    this.age=age;
}
function Son(uname,age,score){
    Father.call(this,uname,age);//调用Father函数，并将其的this指向改为子类的实例对象
    this.score=score;
}
var son=new Son('刘德华',18,100);
```

#### 借用原型对象继承方法

```js
Father.prototype.money=function(){}
function Son(uname,age,score){
    Father.call(this,uname,age);//调用Father函数，并将其的this指向改为子类的实例对象
    this.score=score;
}
//Son.prototype=Father.prototype;//这样赋值会有问题，如果修改了子原型对象，父原型对象也会跟着变化
Son.prototype=new Father();
//如果利用对象的形式修改了原型对象，别忘了利用constructor指回原来的构造函数
Son.prototype.constructor=Son;
//这个是子构造函数专门的方法
Son.prototype.exam=function(){}

```

### ES5新增的方法

#### 数组方法

>迭代遍历方法：forEach(),map(),filter(),some(),every();
>
>1.forEach()
>
>```js
>var arr=[1,2,3];
>arr.foreach(function(value,index,array){
>    console.log('每个元素'+value);//1
>    console.log('每个元素索引号'+index);//0
>    console.log('数组本身'+array);//[1,2,3]
>})
>```
>
>2.filter()
>
>1）filter()方法创建一个新的数组，新数组中的元素是通过检查数组中符合条件的所有元素，主要用于筛选数组
>
>2）注意他直接返回一个数组
>
>```js
>var arr=[12,66,4,88];
>var newArr=arr.filter(function(value,index,array){
>    return value>=20;
>});
>console.log(newArr);//返回的是66,88的数组，大于20的，最后一个参数可省略
>```
>
>3.some()
>
>1）some方法用于检测数组中的元素是否满足指定条件，就是查找数组中是否有满足条件的元素
>
>2）注意它返回的值是布尔值，如果查找到这个元素就返回true，查不到就返回false
>
>3）如果找到第一个满足条件的元素，则会终止循环，不再继续查找
>
>参数和前两个一样
>
>```js
>var arr=[10,30,4];
>var flag=arr.some(function(value){
>    return value>20;
>});
>console.log(flag);//true
>```
>
>###### some()和filter
>
>1.filter返回的是一个数组，而且是把所有的满足条件的元素返回来
>
>2.some返回的是一个布尔值，如果查找到第一个符合条件的就不会继续查找
>
>在some里面遇到return true就是终止遍历，迭代效率更高；forEach和filter不会终止

#### 商品查询案例

#### 字符串方法

>1.trim()方法会从一个字符串的两端删除空白字符
>
>str.trim();
>
>trim()方法并不影响原字符串本身，它返回的是一个新的字符串

#### 对象方法

>1.Object.keys()用于获取对象自身所有的属性名
>
>Object.keys(obj)
>
>1）效果类似于for...in
>
>2）返回一个由属性名组成的数组
>
>2.Object.defineProperty()定义对象中新属性或修改原有的属性
>
>Object.defineProperty(obj,prop,descriptor);
>
>1）obj:必须。目标对象
>
>2）prop:必须。需要定义或修改的属性名字
>
>3）descriptor:必须。目标属性所拥有的特性，以对象形式{}书写
>
>```js
>var obj={
>    id:1,
>    pname:'小米'，
>    price:1999
>}
>Object.defineProperty(obj,'num',{
>    value:1000//默认为undefined
>});
>Object.defineProperty(obj,'num',{
>    writable:true//默认为false，false不能被修改
>});
>Object.defineProperty(obj,'address',{
>    value:'中国杭州'，
>    writable:true,//默认为false，false不能被修改
>    enumerable:false,//如果值为false，则不允许遍历，默认值是false
>    configurable:false//如果为false,则不允许删除这个属性，不允许在修改第三个参数里面的特性，默认为false
>});
>console.log(obj);
>```
>
>

### 函数的定义和调用

#### 函数定义

>1.自定义函数
>
>function fn(){}
>
>2.函数表达式
>
>var fun=function(){}
>
>3.利用new Function('参数一','参数二','函数体')；
>
>var f=new Function('a','b','console.log(a+b)');
>
>f(1,2);//结果是3
>
>console.log(f instanceof Object);//true
>
>总结：所有函数都是Function的实例对象

#### 函数调用

>1.普通函数
>
>fn();        fn.call();
>
>2.对象函数
>
>o.sayHi();
>
>3.构造函数
>
>new Star();
>
>4.绑定事件函数
>
>btn.onclick=function(){}//点击按钮调用
>
>5.定时器函数
>
>setInterval(function(){},1000)//1秒后调用
>
>6.立即执行函数
>
>(function(){
>
>})();//自动调用

### this指向

>普通函数调用：指向window
>
>构造函数调用：指向实例对象，原型对象里面的方法也指向实例对象
>
>对象方法调用：该方法所属对象
>
>事件绑定方法：绑定事件对象
>
>定时器函数：window
>
>立即执行函数：window

#### 改变函数内部this指向

JS提供了一些函数处理函数内部的this指向问题，常用的有bind(),call(),apply()三种方法

##### call方法

>fn.call(o,1,2);//函数fn的指向为对象o
>
>作用：
>
>1）调用函数
>
>2）可以改变函数内的this指向
>
>3）call的主要作用可以实现继承

##### apply方法

调用函数，改变this指向

fun.apply(thisArg,[argsArray])

>thisArg:this指向
>
>argsArray:传递的值，必须包含在数组里
>
>返回值就是函数的返回值，因为他就是调用函数

>作用：
>
>1）调用函数
>
>2）改变this指向
>
>3）注意：参数必须是数组
>
>4）主要应用：比如可以利用apply借助于数学对象求最大值
>
>```js
>var  arr=[1,66,133,20];
>var max=Math.max.apply(Math,arr);
>console.log(max);//133
>```

##### bind方法（重点）

>bind方法不会调用函数，但是能改变函数内部this指向
>
>fun.bind(thisArg,arg1,arg2,...)
>
>返回值由指定的this值和初始化参数改造的原函数拷贝，是原函数改变this指向之后产生的新函数
>
>```js
>var o={
>    name:'andy'
>};
>function fn(a,b){
>    console.log(a+b);
>}
>var f=fn.bind(o,1,2);
>f();//3
>```

>如果有的函数我们不需要立即调用，但是又想改变这个函数内部的this指向时，要用bind
>
>例如：有一个按钮，当点击之后，就禁用这个按钮，3秒之后开启这个按钮
>
>```js
>var btn=document.querySelector('button');
>btn.onclick=function(){
>    this.disabled=true;
>    setTimeout(function(){
>        this.disabled=false;
>    }.bind(this),3000);//将回调函数中内部的this指向改为当前点击的btn
>}
>```

##### 三种改变this指向方法的区别

>##### 相同点：
>
>都可以改变函数内部的this指向
>
>##### 不同点：
>
>1.call和apply会调用函数，并且改变函数内部this指向
>
>2.call和apply传递的参数不一样，call传递参数aru1,aru2...形式，apply必须数组形式[arg]
>
>3.bind不会调用函数，可以改变函数内部this指向
>
>##### 应用场景
>
>1.call经常做继承
>
>2.apply经常跟数组有关系，比如借助于数学对象实现数组最大值和最小值
>
>3.bind不调用函数，但是还想改变this指向。比如改变定时器内部的this指向

### 严格模式

JS除了提供正常模式外，还提供了严格模式。ES5的严格模式采用具有限制性JS变体的一种方式，即在严格的条件下运行JS代码

严格模式在IE10以上版本的浏览器才会被支持，旧版本浏览器中会被忽略

严格模式对正常的JS语义做了一些更改：

1.消除JS语法的一些不合理、不严谨之处，减少了一些怪异行为

2.消除代码运行的一些不安全之处，保证代码的安全

3.提高编译器效率，增加运行速度

4.禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫，如一些保留字：class,enum,export,extends,import,super不能做变量名

#### 开启严格模式

>严格模式可以应用到这个脚本或个别函数中。因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况
>
>1.为脚本开启严格模式
>
>需要在所有语句之前放一个特定语句“use strict";(或'use strict';)
>
>```html
><script>
>    'use strict';
>    //下面的js代码会按照严格模式执行代码
></script>
><script>
>    (function(){
>        'use strict';
>    //下面的js代码会按照严格模式执行代码
>    })();
></script>
>```
>
>2.为某个函数开启严格模式
>
>```js
>function fn(){
>     'use strict';
>    //下面的js代码会按照严格模式执行代码
>}
>```

#### 严格模式中的变化

>##### 1.变量规定
>
>1）在正常模式中，如果变量没声明就赋值，默认是全局变量。严格模式机制这种用法，变量都先var命令声明，再使用
>
>2）严禁删除已经声明变量，例如，delete x;语法是错误的
>
>##### 2.严格模式下this指向
>
>1）以前在全局作用域函数中this指向window对象
>
>2）严格模式下全局作用域函数中的this指向是undefined
>
>3）以前构造函数在不加new也可以调用，当普通函数，this指向全局对象
>
>4）严格模式下，如果构造函数不加new调用，this会报错
>
>5）new实例化的构造函数指向创建的对象实例
>
>6）定时器this指向的还是window
>
>7）事件、对象还是指向调用者
>
>##### 3.函数的变化
>
>1）函数名中不能有重名的参数
>
>2）函数必须声明在顶层。新版的JS会引入“块级作用域（ES6已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数，如在：if或for循环内部

### 高阶函数

高阶函数是对其他函数进行操作的函数，他接受函数作为参数或将函数作为返回值输出

#### 将函数作为参数（回调函数）

```js
function fn(a,b,callback){
    console.log(a+b);
    callback&&callback();
}
fn(1,2,function(){
    console.log('我是最后调用的');
});
```

### 闭包(closure)

>变量根据作用域的不同分为两种：全局变量和局部变量
>
>闭包：指有权访问另一个函数作用域中变量的函数
>
>简单理解：一个作用域可以访问另一个函数内部的局部变量
>
>```js
>function fn(){
>    var num=10;
>    function fun(){
>        console.log(num);//在fun函数里访问到了另一个函数fn里面的局部变量num
>    }
>    fun();
>}
>fn();//fn就是闭包函数，被访问的变量所在在函数就是闭包
>```

#### 闭包的作用

>fn外面的作用域可以访问fn内部的局部变量
>
>```js
>function fn(){
>    var num=10;
>    function fun(){
>        console.log(num);//在fun函数里访问到了另一个函数fn里面的局部变量num
>    }
>    return fun;
>}
>var f=fn();//f是一个函数
>f();//10
>```
>
>作用：延伸了变量的作用范围

#### 案例1

```js
        // 闭包应用-点击li输出当前li的索引号
        // 1. 我们可以利用动态添加属性的方式
        var lis = document.querySelector('.nav').querySelectorAll('li');
        for (var i = 0; i < lis.length; i++) {
            lis[i].index = i;
            lis[i].onclick = function() {
                // console.log(i);
                console.log(this.index);

            }
        }
        // 2. 利用闭包的方式得到当前小li 的索引号
        for (var i = 0; i < lis.length; i++) {
            // 利用for循环创建了4个立即执行函数
            // 立即执行函数也成为小闭包因为立即执行函数里面的任何一个函数都可以使用它的i这变量
            (function(i) {
                // console.log(i);
                lis[i].onclick = function() {
                    console.log(i);

                }
            })(i);
        }
```

#### 案例2

```js
  // 闭包应用-3秒钟之后,打印所有li元素的内容
        var lis = document.querySelector('.nav').querySelectorAll('li');
        for (var i = 0; i < lis.length; i++) {
            (function(i) {
                setTimeout(function() {
                    console.log(lis[i].innerHTML);
                }, 3000)
            })(i);
        }
```

#### 案例3

```js
        // 闭包应用-计算打车价格 
        // 打车起步价13(3公里内),  之后每多一公里增加 5块钱.  用户输入公里数就可以计算打车价格
        // 如果有拥堵情况,总价格多收取10块钱拥堵费
        // function fn() {};
        // fn();
        var car = (function() {
            var start = 13; // 起步价  局部变量
            var total = 0; // 总价  局部变量
            return {
                // 正常的总价
                price: function(n) {
                    if (n <= 3) {
                        total = start;
                    } else {
                        total = start + (n - 3) * 5
                    }
                    return total;
                },
                // 拥堵之后的费用
                yd: function(flag) {
                    return flag ? total + 10 : total;
                }
            }
        })();
        console.log(car.price(5)); // 23
        console.log(car.yd(true)); // 33

        console.log(car.price(1)); // 13
        console.log(car.yd(false)); // 13
```

### 递归

如果一个函数在内部可以调用其本身，那么这个函数就是递归函数

递归函数的作用和for循环一样

由于递归很容易发生“栈溢出”错误，所以必须要加退出条件return

```js
      // 递归函数 : 函数内部自己调用自己, 这个函数就是递归函数
        var num = 1;

        function fn() {
            console.log('我要打印6句话');

            if (num == 6) {
                return; // 递归里面必须加退出条件
            }
            num++;
            fn();
        }
        fn();
```

#### 案例：1-n的阶乘

```

```

### es6语法

es6说的是2015年后新增的ECMAScript语法规则

#### let关键字

>1.let声明的变量只在处于的块级有效（块级作用域指的是大括号）
>
>2.使用var关键字声明的变量不具备块级作用域的效果
>
>3.let变量防止循环变量变为全局变量
>
>4.let变量不存在变量提升，必须先声明后使用
>
>5.let变量有暂时性死区的特性（不会向块级区外查找，只在块级作用域内查找）
>
>经典问题：for循环中函数打印本次循环的i值，let就是0,1...，是想每个自己的块级作用域查找值；而var是全局变量，循环外调用函数i值都相同，是最后一个

#### const关键字

作用：声明常量，常量就是值（内存地址）不能变化的量

>特点：
>
>1.具有块级作用域的效果
>
>2.声明变量时必须赋一个初始值（不然会报错）
>
>3.常量赋值之后，值不能修改（值对应的内存地址不可修改，若是复杂数据类型（如数组）其中的某个元素值可以修改）

#### var ,let,const的区别

>var:函数级作用域、变量提升（未声明可使用）、值可更改
>
>let:块级作用域、不存在变量提升、值可更改
>
>const:块级作用域、不存在变量提升、值不可更改

>const:存储数据不需要变化，如函数、PI值、数学公式（不会实时监控，销率高）

#### 解构赋值

ES6允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构

>##### 什么是解构赋值？
>
>解构代表分解数据结构，赋值是为变量赋值

##### 数组解构

>##### 数组解构
>
>```js
>let [a,b,c]=[1,2,3]//a,b,c是变量
>console.log(a);//1
>console.log(b);//2
>console.log(c);//3
>//数组解构允许按照一一对应的关系从数组中提取值然后将值赋值给变量
>let arr=[1,2,3];
>let [a,b,c,d,e]=arr;//abc分别是123，de都是undefined，结构不成功就是undefined
>```

##### 对象解构

1.变量的名字匹配对象属性的名字

```js
let person={name:'zhangsan',age=20};
let {name,age}=person;
console.log(name);//zhangsan
console.log(age);//20
```

2.变量名和对象属性名不一样

```js
let person={name:'zhangsan',age=20};
let {name:myName,age:myAge}=person;//myName和myAge属于别名
console.log(myName);//zhangsan
console.log(myAge);//20
```

#### 箭头函数

>()=>{}//()放形参，{}是函数体
>
>const fn=()=>{}
>
>fn();//通过变量名调用

>1.如果函数体只有一句代码，且代码的执行结果就是函数的返回值，函数体大括号可以省略
>
>```js
>const sum=(n1+n2)=>n1+n2;
>```
>
>2.如果形参只有一个，形参外侧的小括号也是可以省略的
>
>```js
>const fn=v=>{
>    alert(v);
>}
>fn(20);
>```
>
>3.箭头函数不绑定this，箭头函数中的this，指向的是函数定义位置的上下文this
>
>```js
>const obj={name:'张三'}
>function fn(){
>    console.log(this);//obj
>    return ()=>{
>        console.log(this);//obj
>    }
>}
>const resFn=fn.call(obj);
>resFn();
>```
>
>

##### 剩余参数

```js
const sum=(...args)=>{//...代表接受多个参数，是一个数组
    let total=0;
    args.forEach(item=>total+=item);
    return total;
};
sum(10,20);//30
sum(10,20,30);//60
```

##### 剩余参数和解构搭配

```js
let students=['wangyu','zhangsan','lisi'];
let [s1,...s2]=students;
console.log(s1);//wangyu
console.log(s2);//['zhangsan','lisi']
```

#### ES6的内置对象扩展

##### Array的扩展方法

>扩展运算符（展开语法）
>
>1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列
>
>```js
>let ary=[1,2,3];
>...ary//1,2,3
>consloe.log(...ary);//1 2 3，逗号作为了分隔符
>```
>
>##### 扩展运算符可以应用于合并数组
>
>方法一
>
>```js
>let ary1=[1,2,3];
>let ary2=[3,4,5];
>let ary3=[...ary1,...ary2];
>```
>
>方法二
>
>```js
>ary1.push(...ary2);
>```
>
>2.利用扩展运算符将伪数组转换为真正的数组
>
>```js
>var oDivs=document.getElementsByTagName('div');//获得的是一个伪数组
>var ary=[...oDivs];//转换为真正的数组，即可调用数组中的方法
>
>```
>
>3.将伪数组转换为数组的另一种方法
>
>构造函数方法：Array.from()
>
>```js
>let arrayLike={
>    '0':'a',
>    '1':'b',
>    '2':'c',
>    length:3
>};
>let arr2=Array.from(arrayLike);//['a','b','c']
>//可接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组
>let arrayLike={
>    '0':'1',
>    '1':'2',
>    length:3
>};
>let arr2=Array.from(arrayLike,item=>item*2);//[2,4]
>```
>
>

## Node.js

服务器端开发

1.可以后端程序员紧密的配合

2.网站业务逻辑前置，学习前端技术需要后端技术支撑（Ajax）

3.扩展知识视野，能够站在更高角度审视整个项目

>##### 服务器端开发要做的事情
>
>1.实现业务的逻辑
>
>2.数据增删改查
>
>##### 为什么选Node
>
>1.使用JS语法开发后端应用
>
>2.一些公司要求前端工程师掌握Node开发
>
>3.生态系统活跃，有大量开源库可以使用
>
>4.前端开发工具大多都给基于Node
>
>##### Node是什么？
>
>Node是一个基于Chorme V8引擎的JavaScript代码运行环境
>
>运行环境：
>
>1.浏览器（软件）能够运行JavaScript代码，浏览器就是JavaScript代码的运行环境
>
>2.Node（软件）能够运行JavaScript代码，Node就是JavaScript代码的运行环境
>
>Chorme V8的作用就是为了用来执行JavaScript代码，Node能运行JavaScript代码，就是因为它内部包含了Chorme V8引擎

>公关网下载稳定版node安装后，打开命令行工具，powershell
>
>命令行工具:就是操作操作系统，和平常使用图形化界面一样
>
>PATH环境变量：存储系统的目录，在命令行中执行命令的时候会自动去这些目录中查找命令的位置

#### Node.js的组成

>Node.js是由ECMAScript及node环境提供的一些附件API组成的，包括文件、网络、路径等等一些强大的API

>Node.js可以运行ECMAScript的基础语法
>
>node  当前文件目录；执行js文件

#### Node.js模块开发

JS在使用时存在两大问题，文件依赖和命名冲突

需要自己分析一个js文件所依赖哪些JS，不同JS中同名变量会覆盖

模块化开发会解决这个问题，是代码处于半开放式，只有开放了的代码才能被其他文件访问到

一个功能就是一个模块，多个模块组成一个应用，抽离出一个模块不会影响其他模块

##### Node.js模块开发规范

>Node.js规定一个JavaScript文件就是一个模块，模块内部定义的变量和函数默认情况下在外部无法得到
>
>模块内部可以使用exports对象进行成员导出，使用require方法导入其他模块

```js
//a.js
const add = (n1, n2) => n1 + n2;
exports.add = add;//模块成员导出
//b.js
const a = require('./node.js');//后缀名可以省略，requir返回的是exports对象
console.log(a.add(10, 20));
//最后用node执行b.js文件
```

##### 模块成员导出的另一种方法

```js
const add = (n1, n2) => n1 + n2;
module.exports.add = add;//模块成员导出,单个导出
module.exports={
    name:'zhangsan'
}//批量导出
```

>exports是module.exports的别名（地址引用关系），默认情况下指的是同一块地址空间，如果而二者不同，最终以module.exports为准

#### 系统模块

>Node运行环境提供的API。因为这些API都是以模块化的方式进行开发的，所以我们又称Node运行环境提供的API为系统模块

##### 系统模块fs文件操作

>f:file文件，s:system系统，文件系统

>const fs=require('fs');
>
>###### 读取文件内容
>
>fs.reaFile('文件路径/文件名称'[,'文件编码'],callback);//callback回调函数
>
>node.js中所有API的回调函数第一个参数都是err,错误信息。回调函数称为错误优先的回调函数
>
>```js
>//1.通过模块的名字fs对模块进行引用
>const fs = require('fs');
>//2.通过模块内部的readFile读取文件内容
>fs.readFile('./node.js', 'utf-8', (err, doc) => {
>    //如果文件读取出错，err是一个对象，包含错误信息
>    //如果文件读取正确，err是null
>    //doc是文件读取的结果
>    console.log(err);
>    console.log(doc);
>});
>```
>
>

##### 系统模块path路径操作

>为什么要路劲拼接？
>
>1.不同操作系统的路径分隔符不统一
>
>2./public/uploads/
>
>3.windows上是\  /
>
>4.Linux上是/
>
>Linux网站的服务器，现在写的代码可能会运行到Linux系统中，所以要考虑Linux系统
>
>path会根据不同的操作系统进行不同的拼接

>###### 拼接语法
>
>path.join('路径'，'路径'，...)
>
>```js
>const path = require('path');
>var finalPath = path.join('public', 'uploads', 'avator');
>console.log(finalPath);//public\uploads\avator
>```
>
>

#### 第三方模块

别人写好的、具有特定功能的、我们能直接使用的模块即第三方模块，由于第三方模块通常都是由多个文件组成且被放置在一个文件夹中，所以又称为包名

>第三方模块存在的两种形式：
>
>1.以js文件的形式存在，提供现实项目具体功能的API接口。类似于Jquery
>
>2.以命令行工具形存在，辅助项目开发

##### 如何获取第三方模块

>npmjs.com:第三方模块的存储和分发仓库
>
>npm(node package manager):node的第三方模块管理工具
>
>1.下载：npm install 第三方模块//一般下载到命令行工具当前工作的目录下，npm会自动创建一个node_modules,下载的模块就在里边和package-lock.json
>
>2.卸载： npm unintall package 模块名称。//删除node_modules文件
>
>3.全局安装（公共目录，所有项目都能用）和本地安装（只有当前项目可以使用）
>
>  命令行工具：全局安装
>
>  库文件：本地安装

##### 第三方模块nodemon

>nodemon是一个命令行工具，用以辅助项目开发
>
>在Node.js中，每次修改文件都要在命令行工具中重新执行该文件，非常繁琐,使用nodemon就不用
>
>##### 使用步骤：
>
>1.使用npm install nodemon -g下载他；-g全局安装
>
>2.使用命令行工具中用nodemon命令代替node命令执行文件
>
>###### 使用nodemon  文件名；执行该文件，命令行被挂起实时监控文件有误修改，文件修改保存后，会再重新执行此命令
>
>断开操作：ctrl+c

##### 第三方模块nrm

nrm:npm下载地址切换工具

npm默认的下载地址在国外，国内下载速度慢

国内阿里巴巴建立了服务器用于存储node的第三方模块，每隔10分钟和国外网站npmjs.com做同步

>使用步骤
>
>1.使用npm install nrm -g
>
>2.查询可用下载地址 nrm ls
>
>3.切换npm下载地址nrm  use  下载地址名称

##### 第三方模块Gulp

基于node平台开发的前端构建工具

前端构建工具：将机械化操作编写成任务，想要执行机械化操作时执行一个命令行命令任务就能自动执行了

如：项目开发完成要上线时，加快网站访问速度，通常会将html、css、js进行压缩，以前都是手动压缩，构建工具编写了很多命令，执行一个命令就可以进行这些机械化操作

>能做什么？
>
>1.项目上线：HTML、CSS、JS文件压缩
>
>2.语法转换（es6、less...)
>
>3.公共文件抽离
>
>4.修改文件后浏览器自动刷新
>
>Gulp使用
>
>1.在项目目录下，使用npm install gulp下载gulp库文件
>
>2.在项目根目录下建立gulpfile.js文件，名字固定
>
>3.重构项目的文件夹结构src目录放置源代码文件，dist目录放置构建后文件
>
>4.在gulpfile.js文件中编写任务
>
>5.在命令行工具中执行gulp任务（npm install glup-cli -g安装gulp的命令行工具）

>##### Gulp中提供的方法
>
>1.gulp.src():获取任务要处理的文件
>
>2.gulp.dest():输出文件
>
>3.gulp.task():建立gulp任务
>
>4.gulp.watch():监控文件的变化

```js
const gulp = require('gulp'); //引用gulp模块
//使用gulp.task建立任务
//1.任务的名称
//2.任务的回调函数
gulp.task('first', () => {
    console.log('第一个glup');
    //1.获取要处理的文件
    gulp.src('./src/css/index.css')
        .pipe(gulp.dest('dist/css')); //必须写在pipe里边

});
```

>最后在命令行输入gulp  任务名；就可以看到dist文件下的内容了

##### Gulp插件

>1.gulp-htmlmin:html文件压缩
>
>2.

## Git

下载：https://npm.taobao.org/mirrors/git-for-windows/

是一个版本管理控制系统（VCS），它可以在任何时间点，将文档的状态作为更新记录保存起来，也可以在任何时间点，将更新记录恢复起来

#### Git的工作流程

>git仓库：用于存储提交记录（项目状态）
>
>暂存区：临时存放被修改文件
>
>工作目录：被Git管理的项目目录（项目文件夹，写代码的地方）
>
>开发人员向git仓库提交项目状态，都将修改的工作目录提交到暂存区，再将暂存区的文件提交到git仓库

#### Git的使用

##### 1.使用前配置

在使用git前，需要告诉git你是谁，在向git仓库中提交时需要用到

>1.配置提交人姓名：git config --global user.name 提交人姓名
>
>2.配置提交人邮箱：git config --global user.email 提交人邮箱
>
>3.查看git配置信息：git config --list
>
>注意：
>
>1.如果对配置信息进行修改，重复上述命令即可
>
>2.配置只需要执行一次

##### 2.提交步骤

>1.git init初始化git仓库（会在文件根目录下生产.git文件，默认隐藏）
>
>2.git status查看文件状态（被管理的文件、和没被管理的文件）
>
>3.git add 文件列表（文件名）     追踪文件（将工作没目录想要被git管理的文件提交到暂存区）     无提示正常
>
>4.git commit -m 提交信息（提交说明）    向仓库中提交代码（每次提交一个功能）
>
>5.git log 查看提交记录

##### 3.撤销

>1.用暂存区的文件覆盖工作目录中的文件：git  checkout  文件
>
>应用场景：程序员将文件提交到暂存区后继续开发，后来发现有问题，需要还原原来的样子
>
>2.将文件从暂存区中删除：git rm --cacahed 文件（暂存区就没有这个文件里，但工作目录有）
>
>应用场景：在工作中目录下有些测试文件，不想让git 管理，但不小心添加到了暂存区中，需要删除
>
>3.将git仓库中指定的更新记录恢复出来，并且覆盖暂存区和工作目录：git  rest  --hard  commitID
>
>应用场景：工作目录中代码存在问题、git仓库的一些提交记录也存在问题，希望将更早的提交记录恢复出来，并删除有问题的提交记录

#### git分支

分支就是副本，相当于将工作目录复制了一份

可以在不同的副本做不同的事情，互不影响

>1.主分支（master）：第一次向git仓库中提交更新记录时自动产生一个分支（就是一个时间轴，什么时候体检，有哪些内容）
>
>主分支是最后确定的，保持稳定性，自动创建
>
>2.开发分支（develop)：作为开发的分支，基于master分支创建
>
>在开发分支开发后，合并到主分支
>
>3.功能分支（feature）：作为开发工具功能的分支，基于开发分支创建
>
>在功能分支开发功能后，合并到开发分支
>
>##### 为什么？
>
>因为开发分支也要保持最大程度的稳定性，创建功能修改分支，修改bug也可以开发分支，不同版本也可以创建分支

##### 1.分支命令

>1.git branch 查看分支
>
>2.git branch 分支名称    创建分支
>
>3.git checkout 分支名称   切换分支（切换分支之前必须要将修改的内容提交，不然会出现问题）
>
>4.git merge 来源分支    合并分支（先切换到上一级分支，来源分支是下一级）
>
>5.git branch -d 分支名称 删除分支 （分支被合并后才允许删除，防止误删）（-D强制删除）

##### 2.暂时保存更改

应用场景：现在处于一个分支，但是老板告诉另外一个分支的代码有问题，需要在不提交此分支的前提下，切换分支

>在git中，可以暂时提取分支上所有的改动并存储，让开发人员得到一个干净的工作副本，临时转向其他工作
>
>使用场景：分支临时切换
>
>存储临时改动：git  stash(相当于剪切到git提供的剪切板上)
>
>恢复改动：git stash pop（将剪切板的内容粘贴进来）
>
>存储临时改动和恢复改动两个得是同一个分支

## Github

git是本地仓库，github是公共远程仓库

流程：

##### 1.A在自己的计算创建本地仓库（git 初始化、暂存区、提交到仓库）

##### 2.A在github中创建远程仓库（在github创建）

##### 3.A将本地仓库推送到远程仓库（git push -u origin master）origin是远程仓库的地址，-u会记住远程仓库地址和分支

1）为远程仓库起别名：git remote add orgin(起的地址名) 地址

git push origin master（无-u）

2）简单是提交：git push（因为有-u记住了）

4.B克隆远程仓库到本地进行开发（B的本地仓库）

新建一个本地仓库文件夹

git  clone 仓库地址（第一次加入项目开发时使用）

##### 5.B将本地仓库中开发的内容推送到远程仓库

程序员B不可以向远程仓库提交代码，需要程序员A要求程序员B成为当前项目的开发者

github中：setting-Manage access-程序员B账号-添加-copy link-发送给程序员B

程序员B：登录-访问邀请链接-直接粘贴浏览器地址-点击接受邀请-获得操作权限

git push origin master（可以使用程序员A为远程仓库起的别名）

##### 6.A将远程仓库中的最新内容拉到本地

git pull 远程仓库地址  分支名称（有本地仓库的基础上使用，为了更新本地仓库）

注：如果远程仓库的版本高于本地仓库的版本，是不能直接向远程仓库提交的，必须先将远程仓库的版本拉取到本地

##### 7.解决冲突

>###### 团队之间：
>
>多个人一起开发一个项目时，如果两个人修改同一个文件的同一个地方，就会发生冲突，冲突需要人为解决
>
>如果程序员A已经提交了新的版本，而程序员也在本地修改了同一文件，远程提交时会遇到冲突，需要先将远程的拉取到本地，此时会报冲突，打开代码，需要手动删除提示冲突的代码，再次提交
>
>###### 非团队之间也可提交代码
>
>应用场景：开发一个网页效果，比较浪费时间，不想花费时间，在github中找到效果库，但是并不完善，于是便可以自己完善，将完善的内容发给原仓库作者，原作者如果觉得合适，就合并到自己的仓库
>
>程序员C访问了程序员A的仓库-Fork一下（复制）-克隆仓库到本地-修改-提交到本地仓库-提交到远程-点击pull request-New pull request-填写对方用户名-create pull request-可以和对方对话（主题，内容）-
>
>审核程序员C的内容：点击Commits-Files changed可看修改的内容-Conversation-Mrege pull request（合并）将C的内容合并的原仓库

##### ssh免登录

之前的都是https协议，需要身份验证，用户必须提供用户名和密码

win10第一次可以记住用户名和密码

github提供了ssh协议，不需要用户名和密码可以免登录

>通过秘钥实现，公钥（锁，放在github账户中）和私钥（钥匙，保留在开发者电脑上），使用命令生成，实际上就是一个文件，二者有一个配对的过程
>
>项目根目录下-ssh-keygen-一路回车（生成一对公钥私钥）存储在用户目录下，.ssh文件
>
>github-点击头像setting-ssh-new ssh-复制公钥到其中-提交
>
>github-点击头像Your respositories(你的仓库）-点击进去-Clone  or download-Use ssh-复制地址-向github推送内容

##### 为仓库添加详细说明

在项目的根目录下创建readme.md文件，写上一些说明

将改文件推送到远程仓库，添加到暂存区使用的是git add .

## Ajax

提高用户浏览网站体验

传统网站的问题：

1.获得新数据时只能刷新浏览器，向服务器发送新的请求。网速慢的情况下，页面加载时间长，用户只能等待

2.用户提交表单时，如果一项内容不合格，就会跳转到表单页面，以前填写的都消失，需要重新填写所有表单内容

3.页面跳转时，重新加载页面，造成资源浪费，增加用户等待时间

>它是浏览器提供的一套方法，可以实现页面无刷新更新数据，提高用户浏览网站的应用体验
>
>###### 应用场景：
>
>1.页面上拉加载数据
>
>2.列表数据无刷新分页
>
>3.表单项离开焦点数据验证（避免页面跳转，重新填写数据）
>
>4.搜索框提示文字下拉列表

### Ajax的运行环境

Ajax技术需要运行在网站环境中才能生效，会使用Node创建的服务器作为网站服务器

### Ajax运行原理及实现

Ajax相当于浏览器发送请求与接收响应的代理人，以实现不影响用户浏览网页的情况下，局部更新页面数据，从而提高用户体验

>##### 实现步骤:
>
>1.创建Ajax对象(为浏览器创建代理人)
>
>var xhr=new  XMLHttpRequest();//XML是服务器与客户端传输内容的数据格式，现在一般是json格式，xml作为了解
>
>2.告诉Ajax请求地址以及请求方式
>
>xhr.open('get','http://www.baidu.com');
>
>3.发送请求
>
>xhr.send();
>
>4.获取服务器给与客户端的相应数据
>
>```js
>xhr.onload=function(){//当服务器向客户端响应了数据时，自动调用onload事件
>    console.log(xhr.responseText);//responseText服务器端相应的数据
>}
>```
>
>该第四个视频了

## VUEX

> 组将之间共享数据：
>
> 1.父向子传值：v-bind属性绑定
>
> 2.子向父传值：v-on属性绑定
>
> 3.兄弟组件之间共享数据：EventBus
>
> 1)$on接受数据的那个组件
>
> 2)$emit发送数据的那个组件
>
> ###### 以上适合小范围的数据共享

>VUEX是实现组件全局状态（数据）管理的一种机制，可以方便的实现组件之间的数据的共享
>
>vuex将共享的数据放到store，可直接从里边去
>
>##### 使用vuex的优点：
>
>1.能够在vuex中集中管理共享的数据，易于开发和后期维护
>
>2.能够高效的实现组件之间的数据共享，提高开发效率
>
>3.存储在vuex中的数据都是响应式的，能够实现保持数据与页面的同步

### Vuex的基本使用

> 1.npm  install vuex --save
>
> 2.导包：import Vuex from 'vuex'
>
> ​     Vue.use(Vuex)
>
> 3.创建store对象：(store.js中)
>
> const store=new Vuex.Store({
>
>   //state中存放的就是全局共享的数据
>
>   state:{count:0}
>
> })
>
> 4.将store对象挂载到vue实例中
>
> new Vue({
>
>  el:'#app',
>
>  render:h=>h(app),
>
>  router,
>
>  store //所有的组件都可以从store中获取全局的数据
>
> })

> components:将组件注册为私有组件，最好为通过import引入的组件以键值对方式起一个别名，然后就可以以标签的形式使用了

### Vuex的核心概念

#### State

> ##### 1.state
>
> state提供唯一的公共数据源，所有共享的数据都要统一放到Store的state中进行存储
>
> ##### 组件访问state中的共享数据的方式
>
> 1.this.$store.state.count
>
> 2.
>
> 1）从vuex中按需导入mapState函数
>
>   import {mapState} from 'vuex'
>
> 通过刚才导入的mapState函数，将当前组件需要的全局数据，映射为当前组件的computed计算属性
>
> 2）将全局数据，映射为当前组件的计算属性
>
> computed:{
>
>    ...mapState(['count']) //...展开运算符，将count里的值映射到computed
>
> }
>
> 使用：{{count}}

#### Mutation

> Mutation是写在store对象里的，Mutation中可以定义多个函数，其他组件可以调用其中的方法
>
> ```js
> (store.js中)
> mutation:{
>     addN(state,step){
>         state.count+=step
>     }，
>     add(state){
>         state.count+=1
>     }
> }
> ```
>
> 调用时（组件）
>
> ```js
> handle(){
>     //commit是用来触发mutation里的函数的
>     this.$store.commit('addN',3)
> }
> ```
>
> ###### 注意：Mutation函数中不能写异步代码，如果要加异步函数，要使用Action处理

#### Action

用来处理异步任务，如果通过异步操作变更数据，必须通过Action，而不能使用Mutation，但是在Action中还是要通过触发Mutation的方式间接变更数据

##### 1.触发action的第一种方式（dispatch）

> ```js
> (store.js中)
> actions:{
>  addAsync(context){
>      setTimeout(()=>{
>          context.commit('add') //commit的是Mutation里的函数
>      },1000)
>  }
> }
> ```
>
> 触发action函数（dispatch）（组件）
>
> ```js
> handle(){
>     //触发action的第一种方法
>     this.$store.dispatch('addAsync')
> }
> ```
>
> 

>触发actions异步任务时携带参数
>
>```js
>(store.js中)
>actions:{
>addNAsync(context,step){
>  setTimeout(()=>{
>      context.commit('addN',step) //commit的是Mutation里的函数
>  },1000)
>}
>}
>```
>
>触发action函数（dispatch）（组件）
>
>```js
>handle(){
> //触发action的第一种方法
> this.$store.dispatch('addNAsync',5)
>}
>```
>
>

##### 2.触发action的第二种方式

>1.从vuex中按需导入mapActions函数
>
>```js
>import {mapActions} from 'vuex'
>```

通过刚才导入的mapActions函数，将需要的actions函数，映射为当前组件的methods方法：

>2.将指定的actions函数，映射为当前组件的methods函数
>
>```js
>methods:{
>    ...mapActions(['addASync','addNASync'])
>}
>//可直接在函数中通过this.addASync()调用方法
>addASync()成为本页面内的自身的函数
>```
>
>

#### Getter

Getter用于对Store中的数据进行加工处理形成新的数据

>1.Getter可以对Store中已有的数据加工处理之后形成新的数据，类似Vue的计算属性
>
>2.Store中数据发生变化，Getter的数据也会跟着变化

```js
//定义Getter(store.js)
const store=new Vuex.Store({
    state:{
        count:0
    },
    getters:{
        showNum:state=>{
            return '当前最新数量是'+state.count+''
        }
    }
})
```

使用getters的第一种方式

```vue
<h3>{{this.$store.getters.名称}}</h3>//showNum
```

使用getters的第二种方式

```js
import {mapGetters} from 'vuex'
computed:{
    ...mapGetters(['showNum'])
}//映射为自己组建的计算属性
<h3>{{showNum}}</h3>
```

